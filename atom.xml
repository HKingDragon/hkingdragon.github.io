<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dragon&#39;s Blog</title>
  
  
  <link href="https://github.com/HKingDragon/hkingdragon.github.io/atom.xml" rel="self"/>
  
  <link href="https://github.com/HKingDragon/hkingdragon.github.io/"/>
  <updated>2022-05-05T02:21:36.885Z</updated>
  <id>https://github.com/HKingDragon/hkingdragon.github.io/</id>
  
  <author>
    <name>Dragon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux入门</title>
    <link href="https://github.com/HKingDragon/hkingdragon.github.io/2022/04/27/Linux%E5%85%A5%E9%97%A8/"/>
    <id>https://github.com/HKingDragon/hkingdragon.github.io/2022/04/27/Linux%E5%85%A5%E9%97%A8/</id>
    <published>2022-04-27T11:30:41.000Z</published>
    <updated>2022-05-05T02:21:36.885Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=530 height=450 src="https://music.163.com/outchain/player?type=0&id=2560753628&auto=1&height=430"></iframe><h1 id="Linux命令汇总"><a href="#Linux命令汇总" class="headerlink" title="Linux命令汇总"></a>Linux命令汇总</h1><h2 id="Linux的简介"><a href="#Linux的简介" class="headerlink" title="Linux的简介"></a>Linux的简介</h2><p>​Linux，全称GNU&#x2F;Linux，是一种免费使用和自由传播的<a href="https://baike.baidu.com/item/%E7%B1%BBUNIX/9032872">类UNIX</a>操作系统，其内核由<a href="https://baike.baidu.com/item/%E6%9E%97%E7%BA%B3%E6%96%AF%C2%B7%E6%9C%AC%E7%BA%B3%E7%AC%AC%E5%85%8B%E7%89%B9%C2%B7%E6%89%98%E7%93%A6%E5%85%B9/1034429">林纳斯·本纳第克特·托瓦兹</a>于1991年10月5日首次发布，它主要受到<a href="https://baike.baidu.com/item/Minix/7106045">Minix</a>和Unix思想的启发，是一个基于<a href="https://baike.baidu.com/item/POSIX">POSIX</a>的多用户、<a href="https://baike.baidu.com/item/%E5%A4%9A%E4%BB%BB%E5%8A%A1/1011764">多任务</a>、支持<a href="https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404">多线程</a>和多<a href="https://baike.baidu.com/item/CPU">CPU</a>的操作系统。它能运行主要的<a href="https://baike.baidu.com/item/Unix/219943">Unix</a>工具软件、应用程序和网络协议。它支持<a href="https://baike.baidu.com/item/32%E4%BD%8D/5812218">32位</a>和<a href="https://baike.baidu.com/item/64%E4%BD%8D">64位</a>硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。Linux有上百种不同的发行版，如基于社区开发的<a href="https://baike.baidu.com/item/debian/748667">debian</a>、<a href="https://baike.baidu.com/item/archlinux/10857530">archlinux</a>，和基于商业开发的[Red Hat Enterprise Linux](<a href="https://baike.baidu.com/item/Red">https://baike.baidu.com/item/Red</a> Hat Enterprise Linux&#x2F;10770503)、<a href="https://baike.baidu.com/item/SUSE/60409">SUSE</a>、[Oracle Linux](<a href="https://baike.baidu.com/item/Oracle">https://baike.baidu.com/item/Oracle</a> Linux&#x2F;6876458)等。</p><h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3><ul><li><p><strong>基本思想</strong></p><p>Linux的基本思想有两点：第一，一切都是文件；第二，每个文件都有确定的用途。其中第一条详细来讲就是系统中的所有都归结为一个文件，包括<a href="https://baike.baidu.com/item/%E5%91%BD%E4%BB%A4">命令</a>、<a href="https://baike.baidu.com/item/%E7%A1%AC%E4%BB%B6">硬件</a>和<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6/12053">软件</a>设备、<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192">操作系统</a>、<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B">进程</a>等等对于操作系统<a href="https://baike.baidu.com/item/%E5%86%85%E6%A0%B8">内核</a>而言，都被视为拥有各自特性或类型的文件。至于说Linux是基于Unix的，很大程度上也是因为这两者的基本思想十分相近。</p></li><li><p><strong>完全免费</strong></p><p>Linux是一款免费的操作系统，用户可以通过网络或其他途径免费获得，并可以任意修改其<a href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81/3969">源代码</a>。这是其他的操作系统所做不到的。正是由于这一点，来自全世界的无数<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E5%91%98/62748">程序员</a>参与了Linux的修改、编写工作，程序员可以根据自己的兴趣和灵感对其进行改变，这让Linux吸收了无数程序员的精华，不断壮大。</p></li><li><p><strong>完全兼容POSIX1.0标准</strong></p><p>这使得可以在Linux下通过相应的<a href="https://baike.baidu.com/item/%E6%A8%A1%E6%8B%9F%E5%99%A8">模拟器</a>运行常见的<a href="https://baike.baidu.com/item/DOS/32025">DOS</a>、Windows的程序。这为用户从Windows转到Linux奠定了基础。许多用户在考虑使用Linux时，就想到以前在Windows下常见的程序是否能正常运行，这一点就消除了他们的疑虑。</p></li><li><p><strong>多用户、多任务</strong></p><p>Linux支持多用户，各个用户对于自己的文件设备有自己特殊的权利，保证了各用户之间互不影响。<a href="https://baike.baidu.com/item/%E5%A4%9A%E4%BB%BB%E5%8A%A1">多任务</a>则是现代电脑最主要的一个特点，Linux可以使多个程序同时并独立地运行。</p></li><li><p><strong>良好的界面</strong></p><p>Linux同时具有字符界面和<a href="https://baike.baidu.com/item/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/8146283">图形界面</a>。在字符界面用户可以通过键盘输入相应的指令来进行操作。它同时也提供了类似Windows图形界面的X-Window系统，用户可以使用鼠标对其进行操作。在X-Window环境中就和在Windows中相似，可以说是一个Linux版的Windows。</p></li><li><p><strong>支持多种平台</strong></p><p>Linux可以运行在多种硬件平台上，如具有<a href="https://baike.baidu.com/item/x86/6150538">x86</a>、680x0、SPARC、Alpha等处理器的平台。此外Linux还是一种嵌入式操作系统，可以运行在掌上电脑、机顶盒或游戏机上。2001年1月份发布的Linux 2.4版内核已经能够完全支持<a href="https://baike.baidu.com/item/Intel/125450">Intel</a>64位芯片架构。同时Linux也支持多处理器技术。多个处理器同时工作，使系统性能大大提高。</p></li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li><p>Linux由众多微内核组成，其源代码完全开源；</p></li><li><p>Linux继承了<a href="https://baike.baidu.com/item/Unix/219943">Unix</a>的特性，具有非常强大的网络功能，其支持所有的因特网协议，包括TCP&#x2F;<a href="https://baike.baidu.com/item/IPv4/422599">IPv4</a>、<a href="https://baike.baidu.com/item/TCP/33012">TCP</a>&#x2F;IPv6和链路层拓扑程序等，且可以利用Unix的网络特性开发出新的协议栈；</p></li><li><p>Linux系统工具链完整，简单操作就可以配置出合适的开发环境，可以简化开发过程，减少开发中仿真工具的障碍，使<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F/479832">系统</a>具有较强的移植性；</p></li></ol><h3 id="Linux内核版本"><a href="#Linux内核版本" class="headerlink" title="Linux内核版本"></a>Linux内核版本</h3><p>内核(kernel)是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序，它提供了一个在裸设备与应用程序间的抽象层。</p><p>Linux内核版本又分为稳定版和开发版，两种版本是相互关联，相互循环：</p><ul><li><p>稳定版：</p><p>具有工业级强度，可以广泛地应用和部署。新的稳定版相对于较旧的只是修正一些bug或加入一些新的驱动程序。</p></li><li><p>开发版：</p><p>由于要试验各种解决方案，所以变化很快。</p><p>内核源码网址：<a href="http://www.kernel.org/">http://www.kernel.org</a> 所有来自全世界的对Linux源码的修改最终都会汇总到这个网站，由Linus领导的开源社区对其进行甄别和修改最终决定是否进入到Linux主线内核源码中。</p></li></ul><h3 id="Linux发行版本"><a href="#Linux发行版本" class="headerlink" title="Linux发行版本"></a>Linux发行版本</h3><p>Linux发行版 (也被叫做 GNU&#x2F;Linux 发行版) 通常包含了包括桌面环境、办公套件、媒体播放器、数据库等应用软件。</p><p>目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。</p><h3 id="Linux与Windows的区别"><a href="#Linux与Windows的区别" class="headerlink" title="Linux与Windows的区别"></a>Linux与Windows的区别</h3><ul><li><p>Linux区分大小写，Windows在DOS界面命令下不区分大小写</p></li><li><p>文件系统区别</p><p>在 Windows 下，打开 “计算机”，我们看到的是一个个的驱动器盘符：</p></li></ul><p><img src="https://s2.loli.net/2022/04/28/kSVhvgiKcWRCmYX.png" alt="image-20220428092049606"></p><p>​每个驱动器都有自己的<a href="https://so.csdn.net/so/search?q=%E6%A0%B9%E7%9B%AE%E5%BD%95&spm=1001.2101.3001.7020">根目录</a>结构</p><p>​<img src="https://s2.loli.net/2022/04/28/sD6YBLMpgwV3aoZ.png" alt="在这里插入图片描述"></p><ul><li>在 Linux 下，我们是看不到这些驱动器盘符，我们看到的是文件夹（目录）：<br>linux没有盘符这个概念，只有一个根目录 &#x2F;，所有文件都在它下面</li></ul><p><img src="https://s2.loli.net/2022/04/28/1bzfwZLSVpdJMHq.png" alt="在这里插入图片描述"></p><ul><li><p>Linux所有内容均以文件形式保存包括硬件，用户。Windows文件和硬件没有关系，两个之间没有关联</p></li><li><p>Windows用扩展名区分文件如.exe代表执行文件，.txt代表文本文件，而Linux无扩展名，为了管理员区分会有部分扩展</p></li><li><p>windows平台:数量和质量的优势，不过大部分为收费软件；由微软官方提供重要支持和服务 。</p><p>linux平台：大都为开源自由软件，用户可以修改定制和再发布，由于基本免费没有资金支持，部分软件质量和体验欠缺；有全球所有的Linux开发者和自由软件社区提供支持。</p></li><li><p>windows下的.exe文件不能直接在linux下安装与运行，同时linux大部分是字符界面，大大增加了linux系统的安全性，减少了木马攻击的可能性，同时linux字符界面占用的系统资源要小于windows下的图形界面所占的资源。</p></li></ul><h2 id="文件目录介绍"><a href="#文件目录介绍" class="headerlink" title="文件目录介绍"></a>文件目录介绍</h2><ul><li><p><code>/</code>：</p><p>根目录，一般根目录下只存放目录，在Linux下有且只有一个根目录。</p></li><li><p><code>/bin</code>：</p><p>&#x2F;user&#x2F;bin：可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等</p></li><li><p><code>/boot</code>：</p><p>放置Linux系统启动时用的一些文件，如Linux的内核文件：&#x2F;boot&#x2F;vmlinuz，系统引导管理器：&#x2F;boot&#x2F;grub</p></li><li><p><code>/dev</code>：</p><p>存放在Linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，通常是挂载光驱</p></li><li><p><code>/etc</code>：</p><p>系统配置文件存放的目录</p></li><li><p><code>/home</code>：</p><p>系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，表示当前用户的家目录，edu表示用户edu的家目录</p></li><li><p><code>/lib</code>：</p><p>&#x2F;usr&#x2F;lib：&#x2F;usr&#x2F;local&#x2F;lib：系统使用的函数库目录。程序在执行过程中，需要调用一些额外的参数时需要函数库的协助</p></li><li><p><code>/lost+fount</code>：</p><p>系统异常产生错误时，会将一些遗失的片段放置于此目录下</p></li><li><p><code>/mnt</code>：<code>/media</code>：</p><p>光盘默认挂载点，通常光盘挂载于&#x2F;mnt&#x2F;cdrom下</p></li><li><p><code>/opt</code>：</p><p>给主机额外安装软件所摆放的目录</p></li><li><p><code>/proc</code>：</p><p>此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有&#x2F;proc&#x2F;cpuinfo、&#x2F;proc&#x2F;interrupts、&#x2F;proc&#x2F;dma、&#x2F;proc&#x2F;ioports、&#x2F;proc&#x2F;net&#x2F;* 等。</p></li><li><p><code>/root</code>：</p><p>系统管理员root的家目录。</p></li><li><p><code>/sbin</code>:</p><p>&#x2F;usr&#x2F;sbin: &#x2F;usr&#x2F;local&#x2F;sbin：放置系统管理员使用的可执行命令，如fdisk、shutdown、mount 等。与 &#x2F;bin 不同的是，这几个目录是给系统管理员 root使用的命令，一般用户只能”查看”而不能设置和使用。</p></li><li><p><code>/tmp</code>：</p><p>一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下。</p></li><li><p><code>/srv</code>：</p><p>服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 &#x2F;srv&#x2F;www 内。</p></li><li><p><code>/usr</code>：</p><p>应用程序存放目录，&#x2F;usr&#x2F;bin 存放应用程序，&#x2F;usr&#x2F;share 存放共享数据，&#x2F;usr&#x2F;lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。&#x2F;usr&#x2F;local: 存放软件升级包。&#x2F;usr&#x2F;share&#x2F;doc: 系统说明文件存放目录。&#x2F;usr&#x2F;share&#x2F;man: 程序说明文件存放目录。</p></li></ul><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><h4 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h4><p><strong>显示所有网络接口的配置信息</strong></p><p><img src="https://s2.loli.net/2022/04/28/bxmeGzkOusJoAla.png" alt="image-20220428095340862"></p><p><code>eth33</code> 表示第一块网卡，其中<code>HWaddr</code>表示网卡的物理地址，可以看到目前这个网卡的物理地址(<code>MAC地址</code>）是<code>00:0c:29:0a:42:cd</code>。</p><p><code>inet </code> 用来表示网卡的IP地址，此网卡的IP地址是<code>192.168.205.128</code>，广播地址Broadcast是<code>192.168.205.255</code>，掩码地址<code>Mask:255.255.255.0</code>。</p><p><code>lo</code>是表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。比如把 httpd服务器的指定到回坏地址，在浏览器输入127.0.0.1就能看到你所架WEB网站了。但只是您能看得到，局域网的其它主机或用户无从知道。</p><ul><li>第一行：连接类型：Ethernet（以太网）HWaddr（硬件mac地址）。</li><li>第二行：网卡的IP地址、子网、掩码。</li><li>第三行：UP（代表网卡开启状态）RUNNING（代表网卡的网线被接上）MULTICAST（支持组播）MTU:1500（最大传输单元）：1500字节。</li><li>第四、五行：接收、发送数据包情况统计。</li><li>第七行：接收、发送数据字节数统计信息。</li></ul><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig [网卡名称] [参数]</span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">add&lt;地址&gt;</td><td align="center">设置IPv6地址</td></tr><tr><td align="center">del&lt;地址&gt;</td><td align="center">删除IPv6地址</td></tr><tr><td align="center">down</td><td align="center">关闭指定网卡</td></tr><tr><td align="center">up</td><td align="center">启动指定网卡</td></tr><tr><td align="center">netmask&lt;地址&gt;</td><td align="center">配置子网掩码</td></tr><tr><td align="center">设备名称</td><td align="center">设置网卡名称</td></tr><tr><td align="center">IP地址</td><td align="center">配置IP地址</td></tr><tr><td align="center">-a</td><td align="center">显示所有配置的网络接口，不论是否激活</td></tr><tr><td align="center">broadcast</td><td align="center">配置网关</td></tr><tr><td align="center">-promisc</td><td align="center">关闭或启动指定网络设备的promiscuous模式</td></tr></tbody></table><h4 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h4><ul><li><p>启动关闭指定网卡：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig ens33 up#开启ens33网卡</span><br><span class="line">ifconfig ens33 down #关闭网卡</span><br></pre></td></tr></table></figure></li><li><p>显示所有配置的网络接口，不论是否激活</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig -a</span><br></pre></td></tr></table></figure></li><li><p>显示指定网卡的相关信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig ens33</span><br></pre></td></tr></table></figure></li><li><p>设置网卡成混杂模式以嗅探数据包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig ens33 promisc </span><br></pre></td></tr></table></figure></li><li><p>网卡配置和删除IPv6地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig ens33 add 33ffe:3240:800:1005::2/64#为网卡ens33配置IPv6地址</span><br><span class="line">ifconfig ens33 del 33ffe:3240:800:1005::2/64#为网卡ens33删除IPv6地址</span><br></pre></td></tr></table></figure></li><li><p>ifconfig修改MAC地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig ens33 hw ether 00:AA:BB:CC:dd:EE</span><br></pre></td></tr></table></figure></li><li><p>配置IP地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifconfig ens33 192.168.1.1#配置ens33的IP地址为192.168.1.1</span><br><span class="line">ifconfig ens33 192.168.1.1 netmask 255.255.255.0#配置ens33的IP地址为192.168.1.1，子网掩码为255.255.255.0</span><br><span class="line">ifconfig ens33 192.168.1.1 netmask 255.255.255.0 broadcast 192.168.1.255#配置ens33的IP地址为192.168.1.1，子网掩码为255.255.255.0，网关为192.168.1.255知识补充</span><br></pre></td></tr></table></figure></li></ul><h4 id="知识补充–MAC地址"><a href="#知识补充–MAC地址" class="headerlink" title="知识补充–MAC地址"></a>知识补充–MAC地址</h4><blockquote><p>MAC地址（英语：Media Access Control Address），直译为媒体存取控制位址，也称为局域网地址（LAN Address），MAC位址，以太网地址（Ethernet Address）或物理地址（Physical Address），它是一个用来确认网络设备位置的位址。MAC地址也叫物理地址、硬件地址，由网络设备制造商生产时烧录在网卡(Network lnterface Card)的EPROM(一种闪存芯片，通常可以通过程序擦写)。IP地址与MAC地址在计算机里都是以二进制表示的，IP地址是32位的，而MAC地址则是48位的 。</p></blockquote><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><h4 id="功能描述："><a href="#功能描述：" class="headerlink" title="功能描述："></a>功能描述：</h4><p><strong>测试当前服务器是否可以连接目的主机</strong></p><p><img src="https://s2.loli.net/2022/04/28/5YqGKtc1zMZ2uEp.png" alt="image-20220428095456887"></p><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping [参数] [主机名或IP地址]</span><br></pre></td></tr></table></figure><h4 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h4><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-c</td><td align="center">为发送ping包的数量,到达数量后停止发送</td></tr><tr><td align="center">-s</td><td align="center">字节数：指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节</td></tr><tr><td align="center">-q</td><td align="center">只显示最后的结果</td></tr><tr><td align="center">-t</td><td align="center">存活数值：设置存活数值TTL的大小</td></tr><tr><td align="center">-i</td><td align="center">设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。</td></tr></tbody></table><h4 id="具体使用-1"><a href="#具体使用-1" class="headerlink" title="具体使用"></a>具体使用</h4><ul><li><p>测试主机的连通性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping IP地址或主机</span><br></pre></td></tr></table></figure></li><li><p>测试与网关的连通性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -b 网关地址</span><br></pre></td></tr></table></figure></li><li><p>指定ping的次数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 次数 IP地址或网关</span><br></pre></td></tr></table></figure></li><li><p>ping 设置时间间隔和次数限制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 次数 -i 时间 IP地址或者主机名</span><br></pre></td></tr></table></figure></li><li><p>通过域名ping公网的IP</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 域名</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hjl@hjl-virtual-machine:~$ ping -c 5  baidu.com</span><br><span class="line">PING baidu.com (220.181.38.148) 56(84) bytes of data.</span><br><span class="line">64 字节，来自 220.181.38.148 (220.181.38.148): icmp_seq=1 ttl=128 时间=39.8 毫秒</span><br><span class="line">64 字节，来自 220.181.38.148 (220.181.38.148): icmp_seq=2 ttl=128 时间=39.3 毫秒</span><br><span class="line">64 字节，来自 220.181.38.148 (220.181.38.148): icmp_seq=3 ttl=128 时间=40.7 毫秒</span><br><span class="line">64 字节，来自 220.181.38.148 (220.181.38.148): icmp_seq=4 ttl=128 时间=39.7 毫秒</span><br><span class="line">64 字节，来自 220.181.38.148 (220.181.38.148): icmp_seq=5 ttl=128 时间=39.9 毫秒</span><br></pre></td></tr></table></figure><p>从上方的结果可以看出baidu.com这个域名的公网地址为220.181.38.148</p></li></ul><h4 id="知识补充–Ping"><a href="#知识补充–Ping" class="headerlink" title="知识补充–Ping"></a>知识补充–Ping</h4><blockquote><p>ICMP协议是“Internet Control Message Protocol”（因特网控制消息协议）的缩写。它是TCP&#x2F;IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。</p><p>ping (Packet Internet Groper)，因特网包探索器，用于测试网络连接量的程序。Ping发送一个ICMP；回声请求消息给目的地并报告是否收到所希望的ICMP echo （ICMP回声应答）。它是用来检查网络是否通畅或者网络连接速度的命令</p><p>ping命令通常用来作为网络可用性的检查。ping命令可以对一个网络地址发送测试数据包，看该网络地址是否有响应并统计响应时间，以此测试网络。</p><p>ping和ICMP的关系：ping命令发送数据使用的是ICMP协议。</p></blockquote><blockquote><p>ping的原理：<br>向指定的网络地址发送一定长度的数据包，按照约定，若指定网络地址存在的话，会返回同样大小的数据包，当然，若在特定时间内没有返回，就是“超时”，会被认为指定的网络地址不存在。ICMP协议通过IP协议发送的，IP协议是一种无连接的，不可靠的数据包协议。在Unix&#x2F;Linux,序号从0开始计数，依次递增。而Windows ping程序的ICMP序列号是没有规律。ICMP协议在实际传输中数据包：20字节IP首部 + 8字节ICMP首部 + 1472字节&lt;数据大小&gt;38字节。ICMP报文格式：IP首部（20字节） + 8位类型 + 8位代码 + 16校验和 + （不同类型和代码，格式也有所不同）。</p></blockquote><h3 id="修改IP地址"><a href="#修改IP地址" class="headerlink" title="修改IP地址"></a>修改IP地址</h3><h4 id="IP配置文件位置"><a href="#IP配置文件位置" class="headerlink" title="IP配置文件位置"></a>IP配置文件位置</h4><p><code>/etc/sysconfig/network-scripts/ifcfg-ens33</code></p><h4 id="进入配置文件"><a href="#进入配置文件" class="headerlink" title="进入配置文件"></a>进入配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure><h4 id="解析配置文件内容"><a href="#解析配置文件内容" class="headerlink" title="解析配置文件内容"></a>解析配置文件内容</h4><p>在&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts对网卡的配置文件进行永久性配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet      <span class="comment">#网络类型 以太网</span></span><br><span class="line">BOOTPROTO=static </span><br><span class="line">       <span class="comment">#1.这里可以为=none(过指定方式的办法来获得地址，如果没有指定的话可能会出现各种各样的网络受限 )</span></span><br><span class="line">       <span class="comment">#2.=dhcp 自动获取ip地址</span></span><br><span class="line">       <span class="comment">#3.=static  固定ip地址</span></span><br><span class="line">    DEFROUTE=<span class="built_in">yes</span><span class="comment">#是否设置默认路由</span></span><br><span class="line">    PEERDNS=<span class="built_in">yes</span></span><br><span class="line">    PEERROUTES=<span class="built_in">yes</span></span><br><span class="line">    IPV4_FAILURE_FATAL=no</span><br><span class="line">    IPV6INIT=<span class="built_in">yes</span></span><br><span class="line">    IPV6_AUTOCONF=<span class="built_in">yes</span></span><br><span class="line">    IPV6_DEFROUTE=<span class="built_in">yes</span></span><br><span class="line">    IPV6_PEERDNS=<span class="built_in">yes</span></span><br><span class="line">    IPV6_PEERROUTES=<span class="built_in">yes</span></span><br><span class="line">    IPV6_FAILURE_FATAL=no</span><br><span class="line">    NAME=ens33     <span class="comment">#网卡名称(用户看到的网卡名)</span></span><br><span class="line">    UUID=858e2bc3-1b47-4660-9297-b0029c8cac56 <span class="comment">#网卡的唯一标识符</span></span><br><span class="line">    DEVICE=eth0      <span class="comment">#系统逻辑设备名</span></span><br><span class="line">    ONBOOT=<span class="built_in">yes</span> <span class="comment">#是否开机自启网卡 选项(no/yes)centos7默认no</span></span><br><span class="line">    IPADDR=192.168.1.3       <span class="comment">#指定的ip地址 如果你是dhcp这里是没有的</span></span><br><span class="line">    NETMASK=255.255.255.0    <span class="comment">#子网掩码</span></span><br><span class="line">    GATEWAY=192.168.1.2      <span class="comment">#网关 </span></span><br><span class="line">    DNS1=114.114.114.114     <span class="comment">#指定的第一个DNS服务器</span></span><br></pre></td></tr></table></figure><p>编辑完后，按键盘 <code>esc</code> ，然后输入 <code>:wq</code> 回车即可</p><p>执行 <code>service network restart</code> 重启网络</p><h4 id="知识补充–eth和ens的区别"><a href="#知识补充–eth和ens的区别" class="headerlink" title="知识补充–eth和ens的区别"></a>知识补充–eth和ens的区别</h4><p>一个是真实物理网卡，一个是虚拟网络会话，两者之间的关系就是一个真实物理网卡上可以绑定多个虚拟网络会话。eth0是真实物理网卡，ens33是虚拟网络会话。</p><blockquote><p>修改 IP 地址后可能会遇到的问题：</p><ol><li>物理机能 ping 通虚拟机，但是虚拟机 ping 不通物理机,一般都是因为物理机的 防火墙问题,把防火墙关闭就行</li><li>虚拟机能 Ping 通物理机,但是虚拟机 Ping 不通外网,一般都是因为 DNS 的设置有问题</li><li>虚拟机 Ping <a href="http://www.baidu.com/">www.baidu.com</a> 显示域名未知等信息,一般查看 GATEWAY 和 DNS 设 置是否正确</li><li>如果以上全部设置完还是不行，需要关闭 NetworkManager 服务</li><li>systemctl stop NetworkManager 关闭</li><li>systemctl disable NetworkManager 禁用</li><li>如果检查发现 systemctl status network 有问题 需要检查 ifcfg-ens33</li></ol></blockquote><h3 id="主机名称"><a href="#主机名称" class="headerlink" title="主机名称"></a>主机名称</h3><h4 id="查看当前服务器主机名称"><a href="#查看当前服务器主机名称" class="headerlink" title="查看当前服务器主机名称"></a>查看当前服务器主机名称</h4><p>命令提示符中可以看到主机名，主机名通常位于“@”符号后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hjl@hjl-virtual-machine:~$</span><br><span class="line">主机名为：hjl-virtual-machine</span><br></pre></td></tr></table></figure><p>命令查询</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hostname</span><br><span class="line">uname -n</span><br></pre></td></tr></table></figure><h4 id="临时修改主机名"><a href="#临时修改主机名" class="headerlink" title="临时修改主机名"></a>临时修改主机名</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostname 新主机名</span><br></pre></td></tr></table></figure><blockquote><p>“新主机名”可以用任何合法字符串来表示。不过采用这种方式，新主机名并不保存在系统中，重启系统后主机名将恢复为原先的主机名称。终端下不会立即显示生效后的主机名，重开一个终端窗口(通过ssh连接的终端需要重新连接才可以)。</p></blockquote><h4 id="永久修改主机名"><a href="#永久修改主机名" class="headerlink" title="永久修改主机名"></a>永久修改主机名</h4><p>主机名存放在<code>/etc/hostname</code>文件中，修改主机名时，编辑hostname文件，在文件中输入新的主机名并保存该文件即可。<code>修改完成后重启生效</code></p><blockquote><p>值的指出的是，在其它<a href="http://lib.csdn.net/base/linux">Linux</a>发行版中，并非都存在&#x2F;etc&#x2F;hostname文件。如Fedora发行版将主机名存放在&#x2F;etc&#x2F;sysconfig&#x2F;network文件中。所以，修改主机名时应注意区分是哪种<a href="http://lib.csdn.net/base/linux">linux</a>发行版。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/hostname</span><br></pre></td></tr></table></figure><h3 id="hosts映射"><a href="#hosts映射" class="headerlink" title="hosts映射"></a>hosts映射</h3><p>hosts文件存放在<code>etc/hosts</code>文件中，通过修改该文件可以修改hosts映射。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/hosts</span><br></pre></td></tr></table></figure><p>hosts文件内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1       localhost</span><br><span class="line">127.0.1.1       hjl-virtual-machine</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加hosts映射</span></span><br><span class="line">192.168.1.1    localhost</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改格式</span></span><br><span class="line">IP地址主机名</span><br></pre></td></tr></table></figure><h4 id="知识补充–hosts文件"><a href="#知识补充–hosts文件" class="headerlink" title="知识补充–hosts文件"></a>知识补充–hosts文件</h4><p>hosts是一个文本文件，用来记录IP和hostname（主机名）的映射关系</p><h3 id="远程登陆–ssh"><a href="#远程登陆–ssh" class="headerlink" title="远程登陆–ssh"></a>远程登陆–ssh</h3><blockquote><p>Secure Shell(SSH) 是由 IETF(The Internet Engineering Task Force) 制定的建立在应用层基础上的安全网络协议。它是专为远程登录会话(甚至可以用Windows远程登录Linux服务器进行文件互传)和其他网络服务提供安全性的协议，可有效弥补网络中的漏洞。通过SSH，可以把所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。目前已经成为Linux系统的标准配置。</p></blockquote><h4 id="安装ssh服务"><a href="#安装ssh服务" class="headerlink" title="安装ssh服务"></a>安装ssh服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ssh</span><br></pre></td></tr></table></figure><p>通常在工作过程中，公司中使用的真实服务器或者是云服务器，都不允许除运维人员之外的员工直接接触，因此就需要通过远程登录的方式来操作。</p><p>所以，远程登录工具就是必不可缺的，目前，比较主流的有 Xshell, SSH Secure Shell, SecureCRT,FinalShell 等，可以根据自己的习惯自行选择。</p><blockquote><p>下载地址:(建议使用IDM下载)</p><p>IDM：<a href="http://yun.hjdragon.xyz/%E8%BD%AF%E4%BB%B6/IDM.7z">http://yun.hjdragon.xyz/%E8%BD%AF%E4%BB%B6/IDM.7z</a></p><p>FinalShell：<a href="http://yun.hjdragon.xyz/%E8%BD%AF%E4%BB%B6/FinalShell.7z">http://yun.hjdragon.xyz/%E8%BD%AF%E4%BB%B6/FinalShell.7z</a></p><p>Xshell：<a href="http://yun.hjdragon.xyz/%E8%BD%AF%E4%BB%B6/Xshell-7.0.0090.exe">http://yun.hjdragon.xyz/%E8%BD%AF%E4%BB%B6/Xshell-7.0.0090.exe</a></p></blockquote><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><h3 id="Linux中的进程和服务"><a href="#Linux中的进程和服务" class="headerlink" title="Linux中的进程和服务"></a>Linux中的进程和服务</h3><ul><li><p>计算机中，一个正在执行的程序或命令，被叫做“进程”（process）</p></li><li><p>启动之后一直存在、常驻内存的进程，一般被称作“服务”（service）</p></li></ul><h4 id="进程管理–ps"><a href="#进程管理–ps" class="headerlink" title="进程管理–ps"></a>进程管理–ps</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>Linux 中的 <strong>ps</strong> 命令是 <strong>Process Status</strong> 的缩写。ps 命令用来列出系统中 <strong>当前<strong><strong>正在</strong></strong>运行</strong> 的那些进程，<strong>就是执行 ps 命令的那个时刻的那些进程<strong><strong>的快照</strong></strong>。</strong>使用该命令可以确定有哪些进程 正在运行 和 运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。</p><h5 id="Linux上进程有五种状态"><a href="#Linux上进程有五种状态" class="headerlink" title="Linux上进程有五种状态"></a>Linux上进程有五种状态</h5><blockquote><p>1.运行        ( 正在运行或在运行队列中等待 )  </p><p>2.中断        ( 休眠中, 受阻, 在等待某个条件的形成或接受到信号 ) </p><p>3.不可中断    ( 收到信号不唤醒和不可运行, 进程必须等待直到有中断发生 )  </p><p>4.僵死        ( 进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放 )  </p><p>5.停止        ( 进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行 ) </p></blockquote><h5 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h5><p>1.图形化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gnome-system-monitor#图形化查看进程</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/28/zKSI8WfwFioyne7.png" alt="image-20220428141215658"></p><p>2.使用命令ps</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps#进程查看命令</span><br></pre></td></tr></table></figure><p>参数</p><table><thead><tr><th align="center">-A</th><th align="center">显示所有进程</th></tr></thead><tbody><tr><td align="center">-a</td><td align="center">显示一个终端的所有进程，除了会话引线</td></tr><tr><td align="center">-N</td><td align="center">忽略选择</td></tr><tr><td align="center">-d</td><td align="center">显示所有进程，但忽略所有的会话引线</td></tr><tr><td align="center">-p</td><td align="center">pid进程使用CPU的时间</td></tr><tr><td align="center">-u</td><td align="center">选择有效的用户ID或者是用户名</td></tr><tr><td align="center">-g</td><td align="center">显示组的所有进程</td></tr><tr><td align="center">-m</td><td align="center">显示所有线程</td></tr></tbody></table><p>ps 命令常用用法（方便查看系统进程）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1）ps a   #显示现行终端机下的所有程序，包括其他用户的程序。</span><br><span class="line">2）ps -A  #显示所有进程。</span><br><span class="line">3）ps c   #列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。</span><br><span class="line">4）ps -e  #此参数的效果和指定&quot;A&quot;参数相同。</span><br><span class="line">5）ps e   #列出程序时，显示每个程序所使用的环境变量。</span><br><span class="line">6）ps f   #用 ASCII 字符显示树状结构，表达程序间的相互关系。</span><br><span class="line">7）ps -H  #显示树状结构，表示程序间的相互关系。</span><br><span class="line">8）ps -N  #显示所有的程序，除了执行ps指令终端机下的程序之外。</span><br><span class="line">9）ps s   #采用程序信号的格式显示程序状况。</span><br><span class="line">10）ps S  #列出程序时，包括已中断的子程序资料。</span><br><span class="line">11）ps -t&lt;终端机编号&gt; 　#指定终端机编号，并列出属于该终端机的程序的状况。</span><br><span class="line">12）ps -u root 　#显示root用户信息</span><br><span class="line">13）ps x 　      #显示所有程序，不以终端机来区分。</span><br></pre></td></tr></table></figure><h5 id="进程stat状态"><a href="#进程stat状态" class="headerlink" title="进程stat状态"></a>进程stat状态</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">=========================================进程STAT状态===============================</span><br><span class="line">D     无法中断的休眠状态（通常 IO 的进程）； </span><br><span class="line">R     正在运行，在可中断队列中； </span><br><span class="line">S     处于休眠状态，静止状态； </span><br><span class="line">T     停止或被追踪，暂停执行； </span><br><span class="line">W     进入内存交换（从内核2.6开始无效）； </span><br><span class="line">X     死掉的进程； </span><br><span class="line">Z     僵尸进程不存在但暂时无法消除；</span><br><span class="line">W:    没有足够的记忆体分页可分配</span><br><span class="line">WCHAN 正在等待的进程资源；</span><br><span class="line">&lt;:    高优先级进程</span><br><span class="line">N:    低优先序进程</span><br><span class="line">L:    有记忆体分页分配并锁在记忆体内 (即时系统或捱A I/O)，即,有些页被锁进内存</span><br><span class="line"></span><br><span class="line">s     进程的领导者（在它之下有子进程）； </span><br><span class="line">l     多进程的（使用 CLONE_THREAD, 类似 NPTL pthreads）； </span><br><span class="line">+     位于后台的进程组；</span><br></pre></td></tr></table></figure><h4 id="进程管理–kill"><a href="#进程管理–kill" class="headerlink" title="进程管理–kill"></a>进程管理–kill</h4><h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><blockquote><p>kill命令用来删除执行中的程序或工作。</p></blockquote><p>kill可将指定的信息送至程序。预设的信息为SIGTERM(15)，可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。程序或工作的编号可利用ps指令或job指令查看。</p><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill [选项] 进程号#通过进程号杀死/终止进程</span><br><span class="line">killall 进程名称#通过进程名称杀死/终止进程</span><br></pre></td></tr></table></figure><h5 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h5><table><thead><tr><th align="center">-a</th><th align="center">当处理当前进程是，不限制命令名和进程号的对应关系</th></tr></thead><tbody><tr><td align="center">-l&lt;信息编号&gt;</td><td align="center">若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称</td></tr><tr><td align="center">-p</td><td align="center">指定kill命令只打印相关进程的进程号，而不发送任何信号</td></tr><tr><td align="center">-s&lt;信息名称或编号&gt;</td><td align="center">指定要送出的信息</td></tr><tr><td align="center">-u</td><td align="center">指定用户</td></tr></tbody></table><h5 id="常用信号"><a href="#常用信号" class="headerlink" title="常用信号"></a>常用信号</h5><table><thead><tr><th align="center">HUP</th><th align="center">1</th><th align="center">终端断线</th></tr></thead><tbody><tr><td align="center">INT</td><td align="center">2</td><td align="center">中断（同Ctrl+C）</td></tr><tr><td align="center">QUIT</td><td align="center">3</td><td align="center">退出（同Ctrl+\）</td></tr><tr><td align="center">TERM</td><td align="center">15</td><td align="center">终止（默认kill）</td></tr><tr><td align="center">KILL</td><td align="center">9</td><td align="center">强制终止</td></tr><tr><td align="center">CONT</td><td align="center">18</td><td align="center">继续（与STOP相反，fg&#x2F;bg命令）</td></tr><tr><td align="center">STOP</td><td align="center">19</td><td align="center">暂停（同Ctrl+Z）</td></tr></tbody></table><h5 id="kill-15"><a href="#kill-15" class="headerlink" title="kill -15"></a>kill -15</h5><p>系统会发送一个SIGTERM的信号给对应的程序。当程序接收到该signal后，将会发生以下的事情：</p><p>程序立刻停止；<br>当程序释放相应资源后再停止；<br>程序可能仍然继续运行；<br>大部分程序接收到SIGTERM信号后，会先释放自己的资源，然后在停止。但是也有程序可以在接受到信号量后，做一些其他的事情，并且这些事情是可以配置的。如果程序正在等待IO，可能就不会立马做出相应。也就是说，SIGTERM多半是会被阻塞的、忽略。</p><h5 id="kill-9"><a href="#kill-9" class="headerlink" title="kill -9"></a>kill -9</h5><p>kill -9 pid等于kill -s 9 pid，表示强制，尽快终止一个进程。多半admin会用这个命令。</p><p>因此kill - 9表示强制杀死该进程；与SIGTERM相比，这个信号不能被捕获或忽略，同时接收这个信号的进程在收到这个信号时不能执行任何清理。</p><h4 id="服务管理–systemctl"><a href="#服务管理–systemctl" class="headerlink" title="服务管理–systemctl"></a>服务管理–systemctl</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start | stop | restart | status 服务名#启动/关闭/重启/查看服务</span><br></pre></td></tr></table></figure><h5 id="具体使用-2"><a href="#具体使用-2" class="headerlink" title="具体使用"></a>具体使用</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld#启动防火墙</span><br><span class="line">systemctl stop firewalld#关闭防火墙</span><br><span class="line">systemctl restart firewalld#重新启动防火墙</span><br><span class="line">systemctl status firewalld#查看防火墙的状态</span><br></pre></td></tr></table></figure><h3 id="systemctl-设置后台服务的自启配置"><a href="#systemctl-设置后台服务的自启配置" class="headerlink" title="systemctl 设置后台服务的自启配置"></a>systemctl 设置后台服务的自启配置</h3><h5 id="查看服务开机启动状态"><a href="#查看服务开机启动状态" class="headerlink" title="查看服务开机启动状态"></a>查看服务开机启动状态</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files</span><br><span class="line">systemctl list-unit-files|grep enabled</span><br></pre></td></tr></table></figure><h5 id="关掉指定服务的自动启动"><a href="#关掉指定服务的自动启动" class="headerlink" title="关掉指定服务的自动启动"></a>关掉指定服务的自动启动</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable service_name</span><br></pre></td></tr></table></figure><h5 id="开启指定服务的自动启动"><a href="#开启指定服务的自动启动" class="headerlink" title="开启指定服务的自动启动"></a>开启指定服务的自动启动</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable service_name</span><br></pre></td></tr></table></figure><h5 id="查看启动失败的服务"><a href="#查看启动失败的服务" class="headerlink" title="查看启动失败的服务"></a>查看启动失败的服务</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl --failed</span><br></pre></td></tr></table></figure><h5 id="查看服务是否开机启动"><a href="#查看服务是否开机启动" class="headerlink" title="查看服务是否开机启动"></a>查看服务是否开机启动</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-enabled firewalld.service</span><br></pre></td></tr></table></figure><blockquote><p>查看服务的方法</p><ol><li>cd &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system</li><li>ls -al</li></ol></blockquote><p><img src="https://s2.loli.net/2022/04/28/f4GCyAZqwWzoMEY.png" alt="image-20220428143546469"></p><h4 id="系统运行级别"><a href="#系统运行级别" class="headerlink" title="系统运行级别"></a>系统运行级别</h4><h5 id="查看当前系统运行级别"><a href="#查看当前系统运行级别" class="headerlink" title="查看当前系统运行级别"></a>查看当前系统运行级别</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">runlevel</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出结果</span></span><br><span class="line">N 5</span><br></pre></td></tr></table></figure><p>结果显示第一位是上一次系统运行级别(N表示没有上一次)，第二位表示系统当前运行级别</p><h5 id="Linux系统运行级别"><a href="#Linux系统运行级别" class="headerlink" title="Linux系统运行级别"></a>Linux系统运行级别</h5><table><thead><tr><th align="center">运行级别</th><th align="center">描述</th><th align="center">英文</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">关机模式，系统默认运行级别不能设置为0，否则不能正常启动，一开机就自动关机</td><td align="center">shutdown.target</td></tr><tr><td align="center">1</td><td align="center">单用户模式，root权限，用于系统维护，禁止远程登录，就像Windows下的安全模式</td><td align="center">emergency.target</td></tr><tr><td align="center">2</td><td align="center">多用户模式，没有 NFS 网络支持</td><td align="center">rescure.target</td></tr><tr><td align="center">3</td><td align="center">完整的多用户文本模式，有 NFS，登录后进入控制台命令模式</td><td align="center">multi-user.target</td></tr><tr><td align="center">4</td><td align="center">系统未使用，保留一般不用</td><td align="center"></td></tr><tr><td align="center">5</td><td align="center">图形化模式，登陆后进入图形 GUI 模式</td><td align="center">graphical.target</td></tr><tr><td align="center">6</td><td align="center">重启模式，默认运行级别不能设为6，否则不能设为6，否则不能正常启动，就会一直开机重启</td><td align="center"></td></tr></tbody></table><h5 id="切换系统运行级别（临时生效，重启失效）"><a href="#切换系统运行级别（临时生效，重启失效）" class="headerlink" title="切换系统运行级别（临时生效，重启失效）"></a>切换系统运行级别（临时生效，重启失效）</h5><h6 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init 0</span><br></pre></td></tr></table></figure><h6 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init 6</span><br></pre></td></tr></table></figure><p>切换到字符模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init 3</span><br></pre></td></tr></table></figure><p>切换到图形模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">init 5#需要登陆-切换模式</span><br><span class="line">startx#不需要登陆-启动软件</span><br></pre></td></tr></table></figure><h5 id="切换系统运行级别-永久生效"><a href="#切换系统运行级别-永久生效" class="headerlink" title="切换系统运行级别(永久生效)"></a>切换系统运行级别(永久生效)</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl set-default 级别</span><br></pre></td></tr></table></figure><h6 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl set-default multi-user.target#将系统默认运行级别设置为3</span><br><span class="line">systemctl set-defalut graphical.target#将系统默认运行级别设置为5</span><br></pre></td></tr></table></figure><p>target取 multi-user 或者 graphical</p><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><h4 id="firewalld的基本使用"><a href="#firewalld的基本使用" class="headerlink" title="firewalld的基本使用"></a>firewalld的基本使用</h4><p>启动firewalld</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld</span><br></pre></td></tr></table></figure><p>查看firewalld的状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure><p>停止firewalld</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><p>禁用firewalld</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><h4 id="配置firewalld-cmd"><a href="#配置firewalld-cmd" class="headerlink" title="配置firewalld-cmd"></a>配置firewalld-cmd</h4><p>查看防火墙版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewalld-cmd --version</span><br></pre></td></tr></table></figure><p>查看帮助</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewalld-cmd --help</span><br></pre></td></tr></table></figure><p>显示状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewalld-cmd --status</span><br></pre></td></tr></table></figure><p>查看所有打开的端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure><p>更新防火墙策略</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>查看区域信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --get-active-zones</span><br></pre></td></tr></table></figure><p>查看指定接口所属区域</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --get-zone-of-interface=网卡</span><br></pre></td></tr></table></figure><p>拒绝所有包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --panic-on</span><br></pre></td></tr></table></figure><p>取消拒绝状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --panic-off</span><br></pre></td></tr></table></figure><p>查看是否拒绝</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --query-panic</span><br></pre></td></tr></table></figure><h4 id="防火墙策略-firewalld"><a href="#防火墙策略-firewalld" class="headerlink" title="防火墙策略(firewalld)"></a>防火墙策略(firewalld)</h4><h5 id="firewall-config为图形化工具"><a href="#firewall-config为图形化工具" class="headerlink" title="firewall-config为图形化工具"></a>firewall-config为图形化工具</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1.先开启firewalld，关闭iptables</span><br><span class="line">yum search firewalld</span><br><span class="line">systemctl stop iptables</span><br><span class="line">systemctl mask iptables</span><br><span class="line">systemctl start firewalld</span><br><span class="line"></span><br><span class="line">2.使用工具firewall-config改变firewalld默认的域(默认的是public)</span><br><span class="line"> 选择options---&gt;trusted  所有都可以连接我的主机</span><br><span class="line"> 在block中添加不允许连接的主机ip</span><br><span class="line">      </span><br><span class="line"> 选择options---&gt;block  所有都不可以连接我的主机</span><br><span class="line"> 在trusted中添加允许连接的主机ip</span><br><span class="line"></span><br><span class="line">3.端口转发</span><br><span class="line">    选择options----&gt;trusted-----&gt;port forwarding  </span><br><span class="line">       port/port/range :8888</span><br><span class="line">       local forward :80</span><br><span class="line">       masquerading 勾对号</span><br><span class="line">       浏览器中输入172.25.254.133：8888 自动访问80端口</span><br><span class="line"></span><br><span class="line">      也可以设置为自动转到别的主机的端口</span><br><span class="line">        选择options----&gt;trusted-----&gt;port forwarding  </span><br><span class="line">       port/port/range :22</span><br><span class="line">       forward another port :172.25.254.133  22端口</span><br><span class="line">       masquerading 勾对号</span><br><span class="line">      命令行输入ssh root@172.252.254.233 -X </span><br></pre></td></tr></table></figure><h4 id="firewall命令工具配置策略"><a href="#firewall命令工具配置策略" class="headerlink" title="firewall命令工具配置策略"></a>firewall命令工具配置策略</h4><p>查看已经添加的策略</p><h6 id="查看已经开放的端口"><a href="#查看已经开放的端口" class="headerlink" title="查看已经开放的端口"></a>查看已经开放的端口</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure><h6 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出结果</span></span><br><span class="line">public (active)</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: ens33</span><br><span class="line">  sources: </span><br><span class="line">  services: dhcpv6-client ssh</span><br><span class="line">  ports: </span><br><span class="line">  protocols: </span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br></pre></td></tr></table></figure><h5 id="开启-x2F-移除指定协议的端口"><a href="#开启-x2F-移除指定协议的端口" class="headerlink" title="开启&#x2F;移除指定协议的端口"></a>开启&#x2F;移除指定协议的端口</h5><h6 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd  --add-port=端口号/udp --zone=public --permanent</span><br><span class="line">firewall-cmd  --add-port=端口号/tcp --zone=public --permanent</span><br></pre></td></tr></table></figure><blockquote><p>–zone&#x3D;public：作用域</p><p>–permanent：永久生效</p></blockquote><h6 id="移除端口"><a href="#移除端口" class="headerlink" title="移除端口"></a>移除端口</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --remove-port=端口号/tcp --permanent</span><br></pre></td></tr></table></figure><h5 id="配置IP访问权限"><a href="#配置IP访问权限" class="headerlink" title="配置IP访问权限"></a>配置IP访问权限</h5><h6 id="限制某IP的访问权限"><a href="#限制某IP的访问权限" class="headerlink" title="限制某IP的访问权限"></a>限制某IP的访问权限</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-rich-rule=&quot;rule family=&#x27;ipv4&#x27; source address=&#x27;IP地址&#x27; reject&quot; --permanent</span><br></pre></td></tr></table></figure><p>允许某IP的访问权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-rich-rule=&quot;rule family=&#x27;ipv4&#x27; source address=&#x27;IP地址&#x27; accept&quot; --permanent</span><br></pre></td></tr></table></figure><p>设置某IP通过某端口协议访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-rich-rule &#x27;rule family=ipv4 source address=IP地址 port port=端口 protocol=$tcp accept&#x27;</span><br></pre></td></tr></table></figure><p>设置某IP无法通过某端口协议访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-rich-rule &#x27;rule family=ipv4 source address=IP地址 port port=端口 protocol=$tcp reject&#x27;</span><br></pre></td></tr></table></figure><h5 id="重启防火墙"><a href="#重启防火墙" class="headerlink" title="重启防火墙"></a>重启防火墙</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h4 id="防火墙策略-iptable"><a href="#防火墙策略-iptable" class="headerlink" title="防火墙策略(iptable)"></a>防火墙策略(iptable)</h4><h5 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h5><p>  现代的计算机环境是一个网络的环境，而且是一个非常开放的网络环境，在这个开放的网络环境中，用户可以获得大量的资讯信息，也可以更加轻松地进行社交、学生等。但这个开放的环境也给我们带来了一些不便，在开放的同时，网络中还伴有大量的攻击、发送垃圾邮件、盗号、欺诈等活动。对于IT运维人员而言，如何防止自己的服务器免受攻击？这需要管理员掌握扎实的安全理论基础知识以及专业工具的使用技巧。要防止遭受网络攻击，掌握一种网络访问控制工具的使用是至关重要的，而netfilter&#x2F;iptables 是集成在Linux2.4X版本内核中的包过滤防火墙系统。</p><p>  netfilter&#x2F;iptables 框架可以实现数据包过滤、网络地址转换以及数据包管理功能。Linux中的防火墙系统包括两部分：netfilter&#x2F;iptables。netfilter位于内核空间，目前是Linux内核的组成部分。具体地说，netfilter是Linux内核内部的一系列钩子，这些钩子允许数据表过滤函数挂载到系统内核中。而iptables是用户工具，由于netfilter位于在内核空间中，用户通常接触内核和修改内核，此时就需要一个像iptables这样的命令行工具，使用iptables可以添加、删除具体的过滤规则，iptables默认维护着四个表和五个链，所有的防火墙测落规则都将被分别写入这些表与链中。Linux防火墙因为已经集成在内核中，所以相对于应用层防火墙产品而言，基于内核的Linux防火墙更加快捷、高效。</p><p>  iptables有很好的可扩展性，也就是说，内核架构与iptables工具都可以添加扩展功能，CentOS6.3 系统中防火墙模块存放在&#x2F;lib&#x2F;modules&#x2F;2.6.32-279.e16.x86_64&#x2F;kernel&#x2F;net&#x2F;netfilter 目录下，当需某个模块功能时，可以通过modprobe加载该模块功能。</p><p>  默认的iptables规则表有：filter表（过滤规则表）、nat表（地址转换规则表）、mangle（修改数据标记位规则表）、raw（跟踪数据表规则表）。每个规则表中包含多个数据链：INPUT（入站数据过滤）、OUTPUT（出站数据过滤）、FORWARD（转发数据过滤）、PREROUTING（路由前过滤）和POSTROUTING（路由后过滤），防火墙规则需要写入到具体的数据链中。图1展示了Linux防火墙的过滤框架，从图中可以看出，如果是外部主机发送数据包给防火墙本机，数据将会经过PREROUTING链和INPUT链；如果是防火墙本机发送数据包到外部主机，数据将会经过OUTPUT链和POSTROUTING链；如果防火墙作为路由负责转发数据，则数据将经过PREROUTING链、FORWARD链以及POSTROUTING链。</p><p><img src="https://s2.loli.net/2022/04/28/Gk9tB6v3iKwRJCW.jpg" alt="img"></p><h5 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h5><p>1、规则(rule)<br>规则(rule)就是网络管理员预定的条件，规则一般定义为“如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息包过滤表 中，这些规则分别指定了源地址、目的地址、传输协议(TCP、UDP、ICMP)和服务类型(如HTTP、FTP、SMTP)。当数据包与规则匹配 时，iptables就根据规则所定义的方法来处理这些数据包，如放行(ACCEPT)、拒绝(REJECT)、或丢弃(DROP)等。配置防火墙的主要 规则就是添加、修改和删除这些规则。<br>2、链(chains)<br>链(chains)是数据包传播的路径，每一条链其实就是众多规则中的一个检查清单，每一条链中可以有一条或数条规则。当一个数据包到达一个链 时，iptables就会从链中的第一条规则开始检查，看该数据包是否满足规则所定义的条件，如果满足，系统就会根据该条规则所定义的方法处理该数据包， 否则iptables将继续检查下一条规则。如果该数据包不符合链中任何一何况规则，iptables就会根据该链预先定义的默认策略来处理该数据包。<br>3、表(tables)<br>表(tables)提供特定的功能，iptables内置3个表，即filter表、nat表和mangle表，分别用于实现包过滤，网络地址转换和包重构的功能。<br>(1)filter表。filter表主要用于过滤数据包，该表根据系统管理员预定义的一组规则过滤符合条件的数据包。对防火墙而言，主要利用filter表中指定一系列规则来实现对数据包进行过滤操作。<br>filter表是iptables默认的表，如果没有指定使用哪个表，iptables就默认使用filter表来执行所有的命令。filter表包含了 INPUT链(处理进入的数据包)、FORWARD链(处理转发的数据包)和OUTPUT链(处理本地生成的数据包)。在filter表中只允许对数据包 进行接受或丢弃的操作，而无法对数据包进行更改。<br>(2)nat表。nat青主要用于网络地址转换NAT，该表可以实现一对一、一对多和多对多的NAT工作，iptables就是使用该表实现共享上网功能 的。nat表包含了PREROUTING链(修改即将到来的数据包)、OUTPUT链(修改在路由之前本地生成的数据包)和POSTROUTING链(修 改即将出去的数据包)。<br>(3)mangle表。mangle表主要用于对指定的包进行修改，因为某些特殊应用可能去改写数据包的一些传输特性，例如理性数据包的TTL和TOS等，不过在实际应用中该表的使用率不高。</p><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><p>查看是否已经安装iptables以及iptables版本号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -V #注意：V是大写字母</span><br></pre></td></tr></table></figure><p>关闭iptables</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables stop</span><br></pre></td></tr></table></figure><p>启动iptables</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables start</span><br></pre></td></tr></table></figure><p>重启iptables</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables restart</span><br></pre></td></tr></table></figure><p>保存命令行中设置的iptables规则到iptables文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法1：service iptables save</span><br><span class="line">方法2：etc/rc.d/init.d/iptables save</span><br></pre></td></tr></table></figure><p>查看iptables规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">方法1：iptables -L -n</span><br><span class="line">方法2：service iptables status</span><br><span class="line">方法3：cat /ect/sysconfig/iptables</span><br><span class="line">方法4：iptables --list</span><br><span class="line">方法5：iptables-save</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出结果</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED,DNAT</span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">INPUT_direct  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">INPUT_ZONES  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">DROP       all  --  0.0.0.0/0            0.0.0.0/0            ctstate INVALID</span><br><span class="line">REJECT     all  --  0.0.0.0/0            0.0.0.0/0            reject-with icmp-host-prohibited</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED,DNAT</span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">FORWARD_direct  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">FORWARD_IN_ZONES  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">FORWARD_OUT_ZONES  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">DROP       all  --  0.0.0.0/0            0.0.0.0/0            ctstate INVALID</span><br><span class="line">REJECT     all  --  0.0.0.0/0            0.0.0.0/0            reject-with icmp-host-prohibited</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">OUTPUT_direct  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line"></span><br><span class="line">Chain FORWARD_IN_ZONES (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">FWDI_public  all  --  0.0.0.0/0            0.0.0.0/0           [goto] </span><br><span class="line"></span><br><span class="line">Chain FORWARD_OUT_ZONES (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">FWDO_public  all  --  0.0.0.0/0            0.0.0.0/0           [goto] </span><br><span class="line"></span><br><span class="line">Chain FORWARD_direct (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FWDI_public (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">FWDI_public_pre  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">FWDI_public_log  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">FWDI_public_deny  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">FWDI_public_allow  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">FWDI_public_post  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line"></span><br><span class="line">Chain FWDI_public_allow (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FWDI_public_deny (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FWDI_public_log (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FWDI_public_post (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FWDI_public_pre (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FWDO_public (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">FWDO_public_pre  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">FWDO_public_log  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">FWDO_public_deny  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">FWDO_public_allow  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">FWDO_public_post  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line"></span><br><span class="line">Chain FWDO_public_allow (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FWDO_public_deny (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FWDO_public_log (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FWDO_public_post (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FWDO_public_pre (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain INPUT_ZONES (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">IN_public  all  --  0.0.0.0/0            0.0.0.0/0           [goto] </span><br><span class="line"></span><br><span class="line">Chain INPUT_direct (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain IN_public (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">IN_public_pre  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">IN_public_log  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">IN_public_deny  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">IN_public_allow  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">IN_public_post  all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line"></span><br><span class="line">Chain IN_public_allow (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:22 ctstate NEW,UNTRACKED</span><br><span class="line"></span><br><span class="line">Chain IN_public_deny (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain IN_public_log (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain IN_public_post (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain IN_public_pre (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT_direct (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> 1 --append -A chain 　　　　　　#添加规则到链</span><br><span class="line"> 2 --delete -D chain 　　　　　　#删除规则从链里</span><br><span class="line"> 3 --delete -D chain rulenum 　　　　　　#根据规则号删除</span><br><span class="line"> 4 --insert -I chain [rulenum] 　　　　　　#插入规则默认到第一条</span><br><span class="line"> 5 --list -L [chain [rulenum]] 　　　　 #列表规则</span><br><span class="line"> 6 --flush -F [chain] 　　　　#清空所有规则</span><br><span class="line"> 7 --zero -Z [chain [rulenum]] 　　　　 #计数器</span><br><span class="line"> 8 --policy -P chain target 　　　　　　　　#改默认规则</span><br><span class="line"> 9 --protocol -p proto 　　　　　　　　 #针对协议过滤，例如`tcp&#x27;</span><br><span class="line">10 --source 　　 -s address[/mask][...] #基于源地址</span><br><span class="line">11 --destination -d address[/mask][...] #基于目的地址</span><br><span class="line">12 --in-interface -i input name[+] 　　　 #指定进入接口</span><br><span class="line">13 --jump -j target 　　　　　　　　　 #跳转</span><br><span class="line">14 --numeric -n 　　　　　　　　　　　　 #数字输出地址和端口</span><br><span class="line">15 --out-interface -o output name[+]　　　　　 # 指定出去接口</span><br><span class="line">16 --table -t table 　　　　　　　　 #指定表(default: `filter&#x27;)</span><br><span class="line">17 --line-numbers 　　　　　　　　　　　　　　　　 #显示规则号</span><br></pre></td></tr></table></figure><p>具体操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -nL          #查看指定表filter中的策略 </span><br><span class="line">iptables -t nat -nL             #-n参数存在时显示的是ip，没有的话是主机名</span><br><span class="line">iptables -t mangle -nL   </span><br><span class="line">iptables -F                     #-F：删除指定表中所有规则</span><br><span class="line">iptables -nL </span><br><span class="line">service iptables save           #保存当前策略，保存了之后重启火墙策略重新出现</span><br><span class="line">vim /etc/sysconfig/iptables     #iptables的配置文件</span><br></pre></td></tr></table></figure><p>根据规则iptables的处理动作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 *ACCEPT：允许数据包通过。</span><br><span class="line">2 *DROP：直接丢弃数据包，不给任何回应信息，这时候客户端会感觉自己的请求泥牛入海了，过了超时时间才会有反应。</span><br><span class="line">3 *REJECT：拒绝数据包通过，必要时会给数据发送端一个响应的信息，客户端刚请求就会收到拒绝的信息。</span><br><span class="line">4 *SNAT：源地址转换，解决内网用户用同一个公网地址上网的问题。</span><br><span class="line">5 *MASQUERADE：是SNAT的一种特殊形式，适用于动态的、临时会变的ip上。</span><br><span class="line">6 *DNAT：目标地址转换。</span><br><span class="line">7 *REDIRECT：在本机做端口映射。</span><br><span class="line">8 *LOG：在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则，也就是说除了记录以外不对数据包做任何其他操作，仍然让下一条规则去匹配。</span><br></pre></td></tr></table></figure><p>常用命令操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 iptables -I INPUT -p tcp --dport 23:8809 -j DROP #过滤从23端口到8809端口</span><br><span class="line">2 iptables -I INPUT -p tcp -s 192.168.56.1 -j DROP #封单个IP</span><br><span class="line">3 iptables -I INPUT -p tcp --dport 23:8809 -j DROP #同时封多个端口：从23端口到8809端口</span><br><span class="line">4 iptables -A INPUT -P TCP --dport 80 -j ACCEPT #开发80端口</span><br><span class="line">5 iptables -I OUTPUT -p tcp --dport 80 -j DROP 　#不允许80端口流出</span><br><span class="line">6 iptables -I INPUT -p tcp -m multiport --dport 21,23,24,80,3306 -j DROP #匹配端口范围</span><br><span class="line">7 iptables -A INPUT -p icmp -s 192.168.56.0/24 --icmp-type 8 -j ACCEPT #设置同网段内可以访问（公司内部可以访问，其他人员不能访问）</span><br><span class="line">8 iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT #允许关联的状态包（ftp协议，21连接端口，20数据传输端口）</span><br></pre></td></tr></table></figure><h4 id="防火墙策略（ufw）"><a href="#防火墙策略（ufw）" class="headerlink" title="防火墙策略（ufw）"></a>防火墙策略（ufw）</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>UFW 全称为Uncomplicated Firewall，是Ubuntu 系统上默认的防火墙组件, 为了轻量化配置iptables 而开发的一款工具。 UFW 提供一个非常友好的界面用于创建基于IPV4，IPV6的防火墙规则。</p><h5 id="开启和禁用"><a href="#开启和禁用" class="headerlink" title="开启和禁用"></a>开启和禁用</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ufw enable#开启防火墙</span><br><span class="line">ufw disable#禁用防火墙</span><br><span class="line">ufw reset#重置防火墙，会把你所有已经添加的规则全部删除，并且禁用防火墙</span><br></pre></td></tr></table></figure><h5 id="查看ufw防火墙的状态"><a href="#查看ufw防火墙的状态" class="headerlink" title="查看ufw防火墙的状态"></a>查看ufw防火墙的状态</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ufw status</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">未开启的提示信息</span></span><br><span class="line">Status : inactive</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开启后的提示信息</span></span><br><span class="line">Status : active</span><br></pre></td></tr></table></figure><h5 id="设置默认的防火墙规则，默认为允许"><a href="#设置默认的防火墙规则，默认为允许" class="headerlink" title="设置默认的防火墙规则，默认为允许"></a>设置默认的防火墙规则，默认为允许</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ufw default allow|deny</span><br><span class="line">allow：允许</span><br><span class="line">deny：拒绝</span><br></pre></td></tr></table></figure><h5 id="规则协议"><a href="#规则协议" class="headerlink" title="规则协议"></a>规则协议</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ufw [delete] [insert NUM]  allow|deny [in|out]  [PORT[/PROTOCOL] ]  [comment COMMENT]</span><br><span class="line"> </span><br><span class="line">delete : 删除这个规则</span><br><span class="line">insert : Num代表你要插入到防火墙规则的那个位置，规则是有序排列的。会根据需要来一个个检查</span><br><span class="line">allow|deny : 这条规则是允许的还是禁用的</span><br><span class="line">in|out: 这条规则对发送还是接收数据生效</span><br><span class="line">PORT: 端口号</span><br><span class="line">protocol : 协议，例如TCP还是UDP</span><br><span class="line">comment : 注释</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ufw insert 2 allow in 22/tcp#添加一条允许ssh的规则（ssh的端口号为22，协议是tcp），并且插入到位置2</span><br><span class="line">ufw deny in 22#禁用22端口连入</span><br></pre></td></tr></table></figure><h5 id="IP规则"><a href="#IP规则" class="headerlink" title="IP规则"></a>IP规则</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ufw  [delete]  [insert  NUM]  allow|deny  [in|out  [on INTERFACE]] [proto PROTOCOL] </span><br><span class="line">[from ADDRESS [port PORT]]  [to ADDRESS [port PORT]] [comment COMMENT]</span><br><span class="line"> </span><br><span class="line">INTERFACE ：网卡，就是针对哪个网卡生效，可以使用ifconfig或ip addr查看你的网卡</span><br><span class="line">form ADDRESS  : 源IP地址</span><br><span class="line">to ADDRESS : 目标IP地址</span><br><span class="line">PORT : 跟在源IP地址后面就是源IP地址的端口号，反之则是目标IP地址的端口号</span><br><span class="line">其他的都和协议规则的一致</span><br></pre></td></tr></table></figure><p>具体操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ufw allow proto tcp from 192.168.1.1 port 22 #添加允许192.168.1.1 的22端口tcp协议（ssh）的规则</span><br><span class="line">ufw allow from 192.168.1.1 port 80 to 192.168.1.1 port 8080#允许源IP地址192.168.1.1的8088端口 发送到 目标地址192.162.1.1的8080端口</span><br></pre></td></tr></table></figure><h5 id="删除规则"><a href="#删除规则" class="headerlink" title="删除规则"></a>删除规则</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法1：ufw delete allow 22/tcp#删除ssh规则</span><br><span class="line">方法2：使用序号删除</span><br><span class="line">ufw status numbered#查询策略序号</span><br><span class="line">ufw delete 1#删除第一条规则</span><br></pre></td></tr></table></figure><h2 id="电源管理"><a href="#电源管理" class="headerlink" title="电源管理"></a>电源管理</h2><blockquote><p>前言</p><p>在 linux 领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。</p><p>Linux 系统中为了提高磁盘的读写效率，对磁盘采取了 “预读迟写”操作方式。当用户 保存文件时，Linux 核心并不一定立即将保存数据写入物理磁盘中，而是将数据保存在缓冲区中，等缓冲区满时再写入磁盘，这种方式可以极大的提高磁盘写入数据的效率。</p><p>但是， 也带来了安全隐患，如果数据还未写入磁盘时，系统掉电或者其他严重问题出现，则将导 致数据丢失。使用 sync 指令可以立即将缓冲区的数据写入磁盘。</p></blockquote><h3 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h3><p>功能：将数据由内存同步到硬盘中</p><h3 id="halt"><a href="#halt" class="headerlink" title="halt"></a>halt</h3><p>功能：停机，关闭系统，但是不断电</p><h3 id="poweroff"><a href="#poweroff" class="headerlink" title="poweroff"></a>poweroff</h3><p>功能：关机，断电</p><h3 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h3><p>功能：重启，等同于shutdown -r now</p><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><table><thead><tr><th align="center">选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-H</td><td align="center">相当于-halt，停机</td></tr><tr><td align="center">-f</td><td align="center">-f&#x3D;reboot重启</td></tr></tbody></table><table><thead><tr><th align="center">参数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">now</td><td align="center">立刻关机</td></tr><tr><td align="center">时间</td><td align="center">等待多久后关机（时间单位是分钟）</td></tr></tbody></table><h3 id="具体操作-1"><a href="#具体操作-1" class="headerlink" title="具体操作"></a>具体操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">（1）将数据由内存同步到硬盘中 </span><br><span class="line"><span class="meta prompt_">[root@]#</span><span class="language-bash"><span class="built_in">sync</span></span> </span><br><span class="line">（2）重启 </span><br><span class="line"><span class="meta prompt_">[root@]# </span><span class="language-bash">reboot</span> </span><br><span class="line">（3）停机（不断电） </span><br><span class="line"><span class="meta prompt_">[root@]#</span><span class="language-bash">halt</span> </span><br><span class="line">（4）计算机将在 1 分钟后关机，并且会显示在登录用户的当前屏幕中 </span><br><span class="line"><span class="meta prompt_">[root@]#</span><span class="language-bash">shutdown -h 1 ‘This server will shutdown after 1 mins’</span> </span><br><span class="line">（5）立马关机（等同于 poweroff） </span><br><span class="line"><span class="meta prompt_">[root@]# </span><span class="language-bash">shutdown -h now</span> </span><br><span class="line">（6）系统立马重启（等同于 reboot） </span><br><span class="line"><span class="meta prompt_">[root@]# </span><span class="language-bash">shutdown -r now</span></span><br></pre></td></tr></table></figure><h2 id="软件管理"><a href="#软件管理" class="headerlink" title="软件管理"></a>软件管理</h2><h3 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h3><p>RPM（RedHat Package Manager），RedHat软件包管理工具，是Linux这系列操作系统里面的打包安装工具。</p><h4 id="RPM包的名称格式"><a href="#RPM包的名称格式" class="headerlink" title="RPM包的名称格式"></a>RPM包的名称格式</h4><p><code>Apache-1.3.23-11.i386.rpm</code> - “apache” 软件名称</p><ul><li>“1.3.23-11”软件的版本号，主版本和此版本</li><li>“i386”是软件所运行的硬件平台，Intel 32位处理器的统称</li><li>“rpm”文件扩展名，代表RPM包</li></ul><h4 id="RPM查询命令（rpm-qa）"><a href="#RPM查询命令（rpm-qa）" class="headerlink" title="RPM查询命令（rpm -qa）"></a>RPM查询命令（rpm -qa）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa#查询所安装的所有rpm的软件包</span><br><span class="line">rpm -qa | grep rpm软件包#查询指定rpm包</span><br></pre></td></tr></table></figure><h4 id="RPM卸载命令（rpm-e）"><a href="#RPM卸载命令（rpm-e）" class="headerlink" title="RPM卸载命令（rpm -e）"></a>RPM卸载命令（rpm -e）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -e PRM软件包</span><br><span class="line">rpm -e --nodeps 软件包</span><br></pre></td></tr></table></figure><ul><li>-e：卸载软件包</li><li>–nodeeps：卸载软件时，不检查依赖。这样的话，那些使用该软件包的软件在此之后可能就不能正常工作了</li></ul><h4 id="RPM安装命令（rpm-ivh）"><a href="#RPM安装命令（rpm-ivh）" class="headerlink" title="RPM安装命令（rpm -ivh）"></a>RPM安装命令（rpm -ivh）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh RPM 包全名</span><br></pre></td></tr></table></figure><ul><li>-i：install，安装</li><li>-v：-verbose，显示详细信息</li><li>-h：-hash，进度条</li><li>–nodeps：安装前不检查依赖</li></ul><h3 id="YUM（Fedora-x2F-Centos-x2F-Redhat）"><a href="#YUM（Fedora-x2F-Centos-x2F-Redhat）" class="headerlink" title="YUM（Fedora&#x2F;Centos&#x2F;Redhat）"></a>YUM（Fedora&#x2F;Centos&#x2F;Redhat）</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>YUM（全称为 Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 CentOS 中的 Shell 前端软件包管理器，基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包 并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。</p><h4 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h4><h5 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install PackageName</span><br></pre></td></tr></table></figure><h5 id="删除软件包"><a href="#删除软件包" class="headerlink" title="删除软件包"></a>删除软件包</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove PackageName</span><br></pre></td></tr></table></figure><h5 id="更新软件"><a href="#更新软件" class="headerlink" title="更新软件"></a>更新软件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update PackageName</span><br></pre></td></tr></table></figure><h5 id="列出所有可安装的软件包"><a href="#列出所有可安装的软件包" class="headerlink" title="列出所有可安装的软件包"></a>列出所有可安装的软件包</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list</span><br></pre></td></tr></table></figure><h5 id="列出所有可更新的软件包"><a href="#列出所有可更新的软件包" class="headerlink" title="列出所有可更新的软件包"></a>列出所有可更新的软件包</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list updates</span><br></pre></td></tr></table></figure><h5 id="列出所有已安装的软件包"><a href="#列出所有已安装的软件包" class="headerlink" title="列出所有已安装的软件包"></a>列出所有已安装的软件包</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list installed</span><br></pre></td></tr></table></figure><h5 id="列出所有可以更新的软件包信息"><a href="#列出所有可以更新的软件包信息" class="headerlink" title="列出所有可以更新的软件包信息"></a>列出所有可以更新的软件包信息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum info updates</span><br></pre></td></tr></table></figure><h5 id="列出所有已安装的软件包信息"><a href="#列出所有已安装的软件包信息" class="headerlink" title="列出所有已安装的软件包信息"></a>列出所有已安装的软件包信息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum info installed</span><br></pre></td></tr></table></figure><h5 id="删除缓存的数据"><a href="#删除缓存的数据" class="headerlink" title="删除缓存的数据"></a>删除缓存的数据</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum clean</span><br></pre></td></tr></table></figure><h5 id="查询软件包"><a href="#查询软件包" class="headerlink" title="查询软件包"></a>查询软件包</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum search PackageName</span><br></pre></td></tr></table></figure><h5 id="更新软件包同时考虑软件包取代关系"><a href="#更新软件包同时考虑软件包取代关系" class="headerlink" title="更新软件包同时考虑软件包取代关系"></a>更新软件包同时考虑软件包取代关系</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum upgrade</span><br></pre></td></tr></table></figure><h4 id="配置源"><a href="#配置源" class="headerlink" title="配置源"></a>配置源</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.安装wget</span><br><span class="line">yum install -y wget</span><br><span class="line">2.进入源文件，并将源文件进行备份</span><br><span class="line">cd /etc/yum.repos.d/</span><br><span class="line">mv CentOS-Base.repo CentOS-Base.repo.back</span><br><span class="line">3.下载阿里源或</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">4.清楚缓存</span><br><span class="line">yum clean all</span><br><span class="line">5.产生缓存</span><br><span class="line">yum makecache</span><br><span class="line">6.更新源</span><br><span class="line">yum update</span><br><span class="line">yum upgrade</span><br></pre></td></tr></table></figure><h3 id="apt（Debian-x2F-Ubuntu）"><a href="#apt（Debian-x2F-Ubuntu）" class="headerlink" title="apt（Debian&#x2F;Ubuntu）"></a>apt（Debian&#x2F;Ubuntu）</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p>apt是一个命令行实用程序，用于在Ubuntu，Debian和相关Linux发行版上安装，更新，删除和管理deb软件包。它结合了apt-get和apt-cache工具中最常用的命令以及某些选项的不同默认值。</p><p>apt设计用于交互使用。最好在外壳程序脚本中使用apt-get和apt-cache，因为它们在不同版本之间向后兼容并且具有更多选项和功能。</p><p>大多数apt命令必须以具有sudo特权的用户身份运行。</p><h4 id="安装软件包-1"><a href="#安装软件包-1" class="headerlink" title="安装软件包"></a>安装软件包</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apt-get install PackageName                 // 普通安装</span><br><span class="line">apt-get install PackageName=VersionName     // 安装指定包的指定版本</span><br><span class="line">apt-get --reinstall install PackageName     // 重新安装</span><br><span class="line"></span><br><span class="line">apt-get build-dep PackageName               // 安装源码包所需要的编译环境</span><br><span class="line">apt-get -f install                          // 修复依赖关系</span><br><span class="line"></span><br><span class="line">apt-get source PackageName                  // 下载软件包的源码</span><br></pre></td></tr></table></figure><h4 id="卸载软件包"><a href="#卸载软件包" class="headerlink" title="卸载软件包"></a>卸载软件包</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apt-get remove PackageName              // 删除软件包, 保留配置文件</span><br><span class="line"></span><br><span class="line">apt-get --purge remove PackageName      // 删除软件包, 同时删除配置文件</span><br><span class="line">apt-get purge PackageName               // 删除软件包, 同时删除配置文件</span><br><span class="line"></span><br><span class="line">apt-get autoremove PackageName          // 删除软件包, 同时删除为满足依赖</span><br><span class="line">                                        // 而自动安装且不再使用的软件包</span><br><span class="line"></span><br><span class="line">apt-get --purge autoremove PackageName  // 删除软件包, 删除配置文件, </span><br><span class="line">                                        // 删除不再使用的依赖包</span><br><span class="line"></span><br><span class="line">apt-get clean &amp;&amp; apt-get autoclean      // 清除 已下载的软件包 和 旧软件包</span><br></pre></td></tr></table></figure><h4 id="更新软件包"><a href="#更新软件包" class="headerlink" title="更新软件包"></a>更新软件包</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get update                  // 更新安装源（Source）</span><br><span class="line">apt-get upgrade                 // 更新已安装的软件包</span><br><span class="line">apt-get dist-upgrade            // 更新已安装的软件包（识别并处理依赖关系的改变）</span><br></pre></td></tr></table></figure><h4 id="查询软件包-1"><a href="#查询软件包-1" class="headerlink" title="查询软件包"></a>查询软件包</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l                             // 列出已安装的所有软件包</span><br><span class="line"></span><br><span class="line">apt-cache search PackageName        // 搜索软件包</span><br><span class="line">apt-cache show PackageName          // 获取软件包的相关信息, 如说明、大小、版本等</span><br><span class="line"></span><br><span class="line">apt-cache depends PackageName       // 查看该软件包需要哪些依赖包</span><br><span class="line">apt-cache rdepends PackageName      // 查看该软件包被哪些包依赖</span><br><span class="line"></span><br><span class="line">apt-get check                       // 检查是否有损坏的依赖</span><br></pre></td></tr></table></figure><h4 id="apt-get-–help"><a href="#apt-get-–help" class="headerlink" title="apt-get –help"></a>apt-get –help</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">apt-get --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">apt 2.0.4 (amd64)</span><br><span class="line">用法： apt-get [选项] 命令</span><br><span class="line">　　　 apt-get [选项] install|remove 软件包1 [软件包2 ...]</span><br><span class="line">　　　 apt-get [选项] source 软件包1 [软件包2 ...]</span><br><span class="line"></span><br><span class="line">apt-get 可以从认证软件源下载软件包及相关信息，以便安装和升级软件包，</span><br><span class="line">或者用于移除软件包。在这些过程中，软件包依赖会被妥善处理。</span><br><span class="line"></span><br><span class="line">常用命令：</span><br><span class="line">  update - 取回更新的软件包列表信息</span><br><span class="line">  upgrade - 进行一次升级</span><br><span class="line">  install - 安装新的软件包（注：软件包名称应当类似 libc6 而非 libc6.deb）</span><br><span class="line">  reinstall - 重新安装软件包（注：软件包名称应当类似 libc6 而非 libc6.deb）</span><br><span class="line">  remove - 卸载软件包</span><br><span class="line">  purge - 卸载并清除软件包的配置</span><br><span class="line">  autoremove - 卸载所有自动安装且不再使用的软件包</span><br><span class="line">  dist-upgrade - 发行版升级，见 apt-get(8)</span><br><span class="line">  dselect-upgrade - 根据 dselect 的选择来进行升级</span><br><span class="line">  build-dep - 为源码包配置所需的编译依赖关系</span><br><span class="line">  satisfy - 使系统满足依赖关系字符串</span><br><span class="line">  clean - 删除所有已下载的包文件</span><br><span class="line">  autoclean - 删除已下载的旧包文件</span><br><span class="line">  check - 核对以确认系统的依赖关系的完整性</span><br><span class="line">  source - 下载源码包文件</span><br><span class="line">  download - 下载指定的二进制包到当前目录</span><br><span class="line">  changelog - 下载指定软件包，并显示其变更日志（changelog）</span><br><span class="line"></span><br><span class="line">参见 apt-get(8) 以获取更多关于可用命令的信息。</span><br><span class="line">程序配置选项及语法都已经在 apt.conf(5) 中阐明。</span><br><span class="line">欲知如何配置软件源，请参阅 sources.list(5)。</span><br><span class="line">软件包及其版本偏好可以通过 apt_preferences(5) 来设置。</span><br><span class="line">关于安全方面的细节可以参考 apt-secure(8).</span><br><span class="line">                                         本 APT 具有超级牛力。</span><br></pre></td></tr></table></figure><h4 id="配置源-1"><a href="#配置源-1" class="headerlink" title="配置源"></a>配置源</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.备份apt源的初始版本</span><br><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">2.编辑源列表文件</span><br><span class="line">vi /etc/apt/sources.list</span><br><span class="line">3.将原有的内容注释掉，添加以下内容</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">4.保存文件</span><br><span class="line">5.更新软件列表</span><br><span class="line">apt-get update</span><br><span class="line">6.更新软件包</span><br><span class="line">apt-get upgrade</span><br></pre></td></tr></table></figure><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><h3 id="man获得帮助信息"><a href="#man获得帮助信息" class="headerlink" title="man获得帮助信息"></a>man获得帮助信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man [命令或者配置文件]</span><br></pre></td></tr></table></figure><h3 id="help获得shell内置命令的帮助信息"><a href="#help获得shell内置命令的帮助信息" class="headerlink" title="help获得shell内置命令的帮助信息"></a>help获得shell内置命令的帮助信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help shell命令</span><br></pre></td></tr></table></figure><h3 id="Ctrl-c-停止进程"><a href="#Ctrl-c-停止进程" class="headerlink" title="Ctrl+c 停止进程"></a>Ctrl+c 停止进程</h3><h3 id="Ctrl-l清屏，相当于clear"><a href="#Ctrl-l清屏，相当于clear" class="headerlink" title="Ctrl+l清屏，相当于clear"></a>Ctrl+l清屏，相当于clear</h3><h3 id="reset彻底清屏"><a href="#reset彻底清屏" class="headerlink" title="reset彻底清屏"></a>reset彻底清屏</h3><h3 id="tab键-提示补全命令"><a href="#tab键-提示补全命令" class="headerlink" title="tab键 提示补全命令"></a>tab键 提示补全命令</h3><h3 id="上下键查找执行过的命令"><a href="#上下键查找执行过的命令" class="headerlink" title="上下键查找执行过的命令"></a>上下键查找执行过的命令</h3><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>查看当前工作目录</p><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>切换当前的工作目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd#不输入位置，默认进入用户主目录</span><br><span class="line">cd ~用户名#进入指定用户的主目录</span><br><span class="line">cd .. #进入当前目录的上级目录</span><br></pre></td></tr></table></figure><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>列出当前目录的文件和子目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls [option]</span><br></pre></td></tr></table></figure><p>参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-a：显示所有档案及目录（ls内定将档案名或目录名称为“.”的视为影藏，不会列出）；</span><br><span class="line">-A：显示除影藏文件“.”和“..”以外的所有文件列表；</span><br><span class="line">-C：多列显示输出结果。这是默认选项；</span><br><span class="line">-l：与“-C”选项功能相反，所有输出信息用单列格式输出，不输出为多列；</span><br><span class="line">-F：在每个输出项后追加文件的类型标识符，具体含义：“*”表示具有可执行权限的普通文件，“/”表示目录，“@”表示符号链接，“|”表示命令管道FIFO，“=”表示sockets套接字。当文件为普通文件时，不输出任何标识符；</span><br><span class="line">-b：将文件中的不可输出的字符以反斜线“”加字符编码的方式输出；</span><br><span class="line">-c：与“-lt”选项连用时，按照文件状态时间排序输出目录内容，排序的依据是文件的索引节点中的ctime字段。与“-l”选项连用时，则排序的一句是文件的状态改变时间；</span><br><span class="line">-d：仅显示目录名，而不显示目录下的内容列表。显示符号链接文件本身，而不显示其所指向的目录列表；</span><br><span class="line">-f：此参数的效果和同时指定“aU”参数相同，并关闭“lst”参数的效果；</span><br><span class="line">-i：显示文件索引节点号（inode）。一个索引节点代表一个文件；</span><br><span class="line">--file-type：与“-F”选项的功能相同，但是不显示“*”；</span><br><span class="line">-k：以KB（千字节）为单位显示文件大小；</span><br><span class="line">-l：以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等；</span><br><span class="line">-m：用“,”号区隔每个文件和目录的名称；</span><br><span class="line">-n：以用户识别码和群组识别码替代其名称；</span><br><span class="line">-r：以文件名反序排列并输出目录内容列表；</span><br><span class="line">-s：显示文件和目录的大小，以区块为单位；</span><br><span class="line">-t：用文件和目录的更改时间排序；</span><br><span class="line">-L：如果遇到性质为符号链接的文件或目录，直接列出该链接所指向的原始文件或目录；</span><br><span class="line">-R：递归处理，将指定目录下的所有文件及子目录一并处理；</span><br><span class="line">--full-time：列出完整的日期与时间；</span><br><span class="line">--color[=WHEN]：使用不同的颜色高亮显示不同类型的。</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ls -a#列出所有目录、子目录、文件和隐藏文件</span><br><span class="line">ls -R#列出从当前目录开始的所有的子目录、文件并一层层往下显示</span><br><span class="line">ls -F#列出文件、目录名并显示文件类型</span><br><span class="line">ls -t#以修改时间为时间倒叙来列出文件、子目录</span><br><span class="line">ls -l#以长列表格式显示文件、目录的详细信息</span><br><span class="line">ll#相当于ls -l</span><br><span class="line"></span><br><span class="line">-rw-------. 1 root root 1758 4月  30 13:58 anaconda-ks.cfg</span><br><span class="line"></span><br><span class="line">-rw-------.：文件读写权限</span><br><span class="line">1：如果时目录，那么这个数字代表该目录下有几个子目录</span><br><span class="line">root：所有者</span><br><span class="line">root：所有组</span><br><span class="line">1758：文件大小</span><br><span class="line">4月  30 13：58：文件创建时间</span><br><span class="line">anaconda-ks.cfg：文件名</span><br></pre></td></tr></table></figure><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>创建一个新的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [option] path</span><br></pre></td></tr></table></figure><p>参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-m#对新建的目录设置权限</span><br><span class="line">-p#可以是一个路径名称。此时若路径的某一级目录尚不存在，使有该选项后系统会自动建立这些目录，即一次性建立多级目录</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir dir1#创建目录dir1</span><br><span class="line">mkdir -p ../dir2/dir3/dir4#创建多级目录../dir2/dir3/dir4</span><br><span class="line">mkdir -m 700 dir3#设置dir3的权限为700（权限会在chmod命令中讲）</span><br></pre></td></tr></table></figure><h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><p>删除一个空的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir [option] path</span><br></pre></td></tr></table></figure><p>参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p:   递归删除目录，即将其子目录一起删除</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir dir1#删除目录dir1</span><br></pre></td></tr></table></figure><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>创建空文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch [option] file</span><br></pre></td></tr></table></figure><p>参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">无选项：若文件不存在，则创建新的空文件，access time，modify time和change time均为当前时间；若文件存在，则将三个时间戳均修改为当前时间</span><br><span class="line">-a：只修改文件的access time</span><br><span class="line">-m：只修改文件的modify time</span><br><span class="line">-c：不创建不存在的文件（当touch后操作多个文件时，不存在的文件将不会被创建）</span><br><span class="line">-d：使用指定的日期时间，而非现在的时间，可以使用各种不同的格式。</span><br><span class="line">-t：将时间修改为参数指定的日期</span><br><span class="line">-r file：使用指定file文件的时间戳（access，modify）更新文件的时间戳（access，modify）</span><br></pre></td></tr></table></figure><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>复制文件或目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [option] file 目录</span><br></pre></td></tr></table></figure><p>参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-a：此参数的效果和同时指定&quot;-dpR&quot;参数相同；</span><br><span class="line"></span><br><span class="line">-d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；</span><br><span class="line"></span><br><span class="line">-f：强行复制文件或目录，不论目标文件或目录是否已存在；</span><br><span class="line"></span><br><span class="line">-i：覆盖既有文件之前先询问用户；</span><br><span class="line"></span><br><span class="line">-l：对源文件建立硬连接，而非复制文件；</span><br><span class="line"></span><br><span class="line">-p：保留源文件或目录的属性；</span><br><span class="line"></span><br><span class="line">-R/r：递归处理，将指定目录下的所有文件与子目录一并处理；</span><br><span class="line"></span><br><span class="line">-s：对源文件建立符号连接，而非复制文件；</span><br><span class="line"></span><br><span class="line">-u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件；</span><br><span class="line"></span><br><span class="line">-S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀；</span><br><span class="line"></span><br><span class="line">-b：覆盖已存在的文件目标前将目标文件备份；</span><br><span class="line"></span><br><span class="line">-v：详细显示命令执行的操作。</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp ./test1/test.txt ./#将test文件复制到当前目录下</span><br><span class="line">cp -r /usr/men /usr/zh#将目录/usr/men下的所有文件及其子目录复制到目录/usr/zh中</span><br><span class="line">cp -i /usr/men m*.c /usr/zh#交互式地将目录/usr/men中的以m打头的所有.c文件复制到目录/usr/zh中</span><br><span class="line">cp -f /usr/men m*.c /usr/zh#强制复制无需确定是否执行</span><br></pre></td></tr></table></figure><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>删除文件或目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [option]file</span><br></pre></td></tr></table></figure><p>参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-r 递归删除目录中所有内容</span><br><span class="line">-f 强制执行删除操作，而不提示用于进行确认。</span><br><span class="line">-v 显示指令的详细执行过程</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf test.txt#强制删除test.txt文件</span><br></pre></td></tr></table></figure><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>移动文件与目录或重命名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv file</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv oldnamefile newnamefile#重命名</span><br><span class="line">mv /temp/movefile /targetfolder#移动文件</span><br></pre></td></tr></table></figure><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>查看文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [option] file</span><br></pre></td></tr></table></figure><p>参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-n：显示所有行的行号，包括空行</span><br></pre></td></tr></table></figure><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>文件内容分屏查看器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more file</span><br></pre></td></tr></table></figure><p>操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">空白键 (space) 代表向下翻一页</span><br><span class="line">Enter 代表向下翻『一行』</span><br><span class="line">q 代表立刻离开 more ，不再显示该文件内容</span><br><span class="line">Ctrl+F 向下滚动一屏</span><br><span class="line">Ctrl+B 返回上一屏</span><br><span class="line">= 输出当前行的行号</span><br><span class="line">:f 输出文件名和当前行的行号</span><br></pre></td></tr></table></figure><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>分屏显示文件内容</p><p>less 指令用来分屏查看文件内容，它的功能与 more 指令类似，但是比 more 指令更加 强大，支持各种显示终端。</p><p>less 指令在显示文件内容时，并不是一次将整个文件加载之后 才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less file</span><br></pre></td></tr></table></figure><p>操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">空白键 向下翻动一页；</span><br><span class="line">[pagedown] 向下翻动一页</span><br><span class="line">[pageup] 向上翻动一页；</span><br><span class="line">/字串 向下搜寻『字串』的功能；n：向下查找；N：向上查找；</span><br><span class="line">?字串 向上搜寻『字串』的功能；n：向上查找；N：向下查找；</span><br><span class="line">q 离开 less 这个程序；</span><br></pre></td></tr></table></figure><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>输出内容到控制台</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo [option] file</span><br></pre></td></tr></table></figure><p>参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-n 不要在最后自动换行</span><br><span class="line">-e 若字符串中出现以下字符，则特别加以处理，而不会将它当成一般</span><br><span class="line">文字输出：</span><br><span class="line">   \a 发出警告声；</span><br><span class="line">   \b 删除前一个字符；</span><br><span class="line">   \c 最后不加上换行符号；</span><br><span class="line">   \f 换行但光标仍旧停留在原来的位置；</span><br><span class="line">   \n 换行且光标移至行首；</span><br><span class="line">   \r 光标移至行首，但不换行；</span><br><span class="line">   \t 插入tab；</span><br><span class="line">   \v 与\f相同；</span><br><span class="line">   \\ 插入\字符；</span><br><span class="line">   \nnn 插入nnn（八进制）所代表的ASCII字符；</span><br><span class="line">–help 显示帮助</span><br><span class="line">–version 显示版本信息</span><br></pre></td></tr></table></figure><p>echo的15个用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">1.输入一行文本并显示在标准输出上</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> Tecmint is a community of Linux Nerds</span> </span><br><span class="line">会输出下面的文本:</span><br><span class="line">Tecmint is a community of Linux Nerds </span><br><span class="line"></span><br><span class="line">2.输出一个声明的变量值</span><br><span class="line">比如，声明变量x并给它赋值为10。</span><br><span class="line"><span class="meta prompt_"> $ </span><span class="language-bash">x=10</span></span><br><span class="line">会输出它的值：</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> The value of variable x = <span class="variable">$x</span></span> </span><br><span class="line">输出下面的文本</span><br><span class="line">The value of variable x = 10</span><br><span class="line"></span><br><span class="line">3..使用‘/b‘选项</span><br><span class="line">‘-e‘后带上&#x27;/b&#x27;会删除字符间的所有空格。</span><br><span class="line">注意： Linux中的选项‘-e‘扮演了转义字符反斜线的翻译器。</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">&quot;Tecmint /bis /ba /bcommunity /bof /bLinux /bNerds&quot;</span></span> </span><br><span class="line">输出下方的文本</span><br><span class="line">TecmintisacommunityofLinuxNerds</span><br><span class="line"></span><br><span class="line">4.使用‘/n‘选项</span><br><span class="line">‘-e‘后面的带上‘/n’行会在遇到的地方作为新的一行</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">&quot;Tecmint /nis /na /ncommunity /nof /nLinux /nNerds&quot;</span></span> </span><br><span class="line"></span><br><span class="line">Tecmint </span><br><span class="line">is </span><br><span class="line">a </span><br><span class="line">community </span><br><span class="line">of </span><br><span class="line">Linux </span><br><span class="line">Nerds </span><br><span class="line"></span><br><span class="line">5.使用‘/t‘选项</span><br><span class="line">‘-e‘后面跟上‘/t’会在空格间加上水平制表符。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">&quot;Tecmint /tis /ta /tcommunity /tof /tLinux /tNerds&quot;</span></span> </span><br><span class="line"></span><br><span class="line">Tecmint     is  a   community   of  Linux   Nerds </span><br><span class="line">6.也可以同时使用换行‘/n‘与水平制表符‘/t‘</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">&quot;/n/tTecmint /n/tis /n/ta /n/tcommunity /n/tof /n/tLinux /n/tNerds&quot;</span></span> </span><br><span class="line"></span><br><span class="line">    Tecmint </span><br><span class="line">    is </span><br><span class="line">    a </span><br><span class="line">    community </span><br><span class="line">    of </span><br><span class="line">    Linux </span><br><span class="line">    Nerds </span><br><span class="line">7.使用‘/v‘选项</span><br><span class="line">‘-e‘后面跟上‘/v’会加上垂直制表符。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">&quot;/vTecmint /vis /va /vcommunity /vof /vLinux /vNerds&quot;</span></span> </span><br><span class="line"></span><br><span class="line">Tecmint </span><br><span class="line">        is </span><br><span class="line">           a </span><br><span class="line">             community </span><br><span class="line">                       of </span><br><span class="line">                          Linux </span><br><span class="line">                                Nerds </span><br><span class="line">8.也可以同时使用换行‘/n‘与垂直制表符‘/v‘</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">&quot;/n/vTecmint /n/vis /n/va /n/vcommunity /n/vof /n/vLinux /n/vNerds&quot;</span></span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Tecmint </span><br><span class="line"></span><br><span class="line">is </span><br><span class="line"></span><br><span class="line">a </span><br><span class="line"></span><br><span class="line">community </span><br><span class="line"></span><br><span class="line">of </span><br><span class="line"></span><br><span class="line">Linux </span><br><span class="line"></span><br><span class="line">Nerds </span><br><span class="line">注意： 你可以按照你的需求连续使用两个或者多个垂直制表符，水平制表符与换行符。</span><br><span class="line"></span><br><span class="line">9.使用‘/r‘选项</span><br><span class="line">‘-e‘后面跟上‘/r’来指定输出中的回车符。（LCTT 译注：会覆写行开头的字符）</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">&quot;Tecmint /ris a community of Linux Nerds&quot;</span></span> </span><br><span class="line"></span><br><span class="line">is a community of Linux Nerds </span><br><span class="line">10.使用‘/c‘选项</span><br><span class="line">‘-e‘后面跟上‘/c’会抑制输出后面的字符并且最后不会换新行。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">&quot;Tecmint is a community /cof Linux Nerds&quot;</span></span> </span><br><span class="line"></span><br><span class="line">Tecmint is a community @tecmint:~$ </span><br><span class="line">11.‘-n‘会在echo完后不会输出新行</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -n <span class="string">&quot;Tecmint is a community of Linux Nerds&quot;</span></span> </span><br><span class="line">Tecmint is a community of Linux Nerds@tecmint:~/Documents$ </span><br><span class="line">12.使用‘/a‘选项</span><br><span class="line">‘-e‘后面跟上‘/a’选项会听到声音警告。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">&quot;Tecmint is a community of /aLinux Nerds&quot;</span></span> </span><br><span class="line">Tecmint is a community of Linux Nerds</span><br><span class="line">注意： 在你开始前，请先检查你的音量设置。</span><br><span class="line"></span><br><span class="line">13.使用echo命令打印所有的文件和文件夹（ls命令的替代）</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> *</span> </span><br><span class="line"></span><br><span class="line">103.odt 103.pdf 104.odt 104.pdf 105.odt 105.pdf 106.odt 106.pdf 107.odt 107.pdf 108a.odt 108.odt 108.pdf 109.odt 109.pdf 110b.odt 110.odt 110.pdf 111.odt 111.pdf 112.odt 112.pdf 113.odt linux-headers-3.16.0-customkernel_1_amd64.deb linux-image-3.16.0-customkernel_1_amd64.deb network.jpeg </span><br><span class="line">14.打印制定的文件类型</span><br><span class="line">比如，让我们假设你想要打印所有的‘.jpeg‘文件，使用下面的命令。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> *.jpeg</span> </span><br><span class="line"></span><br><span class="line">network.jpeg </span><br><span class="line">15.echo可以使用重定向符来输出到一个文件而不是标准输出</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;Test Page&quot;</span> &gt; testpage</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Check Content</span></span></span><br><span class="line">avi@tecmint:~$ cat testpage </span><br><span class="line">Test Page </span><br></pre></td></tr></table></figure><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>head 用于显示文件的开头部分内容，默认情况下 head 指令显示文件的前 10 行内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head [option] file</span><br></pre></td></tr></table></figure><p>参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-n#显示行数</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n 5 txt#显示txt文件的头5行</span><br></pre></td></tr></table></figure><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>tail 用于输出文件中尾部的内容，默认情况下 tail 指令显示文件的后 10 行内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [option] file</span><br></pre></td></tr></table></figure><p>参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-n#显示参数</span><br><span class="line">-f#实时追踪该文档的所有更新</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n 5 txt#显示txt文件的尾5行</span><br></pre></td></tr></table></figure><h3 id="gt-输出重定向和-gt-gt-追加"><a href="#gt-输出重定向和-gt-gt-追加" class="headerlink" title="&gt;输出重定向和&gt;&gt;追加"></a>&gt;输出重定向和&gt;&gt;追加</h3><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>“&gt;”：覆盖输出，会覆盖掉原来的内容</p><p>“&gt;&gt;”：追加输出，不会覆盖掉原始文件内容，在原始文件末尾继续添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@freedom ~]# echo &quot;how are you&quot; &gt;one</span><br><span class="line">[root@freedom ~]# cat one</span><br><span class="line">how are you</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@freedom ~]# echo &quot;i am fine&quot; &gt;&gt;one</span><br><span class="line">[root@freedom ~]# cat one</span><br><span class="line">how are you</span><br><span class="line">i am fine</span><br></pre></td></tr></table></figure><h4 id="错误输出"><a href="#错误输出" class="headerlink" title="错误输出"></a>错误输出</h4><p>“2&gt;”：错误覆盖输出，会覆盖掉原来的内容<br>“2&gt;&gt;”：错误追加输出，不会覆盖掉原始文件内容，在原始文件末尾继续添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@freedom ~]# freedom 2&gt;one</span><br><span class="line">[root@freedom ~]# cat one</span><br><span class="line">bash: freedom: 未找到命令...</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@freedom ~]# justice 2&gt;&gt;one</span><br><span class="line">[root@freedom ~]# cat one</span><br><span class="line">bash: freedom: 未找到命令...</span><br><span class="line">bash: justice: 未找到命令...</span><br></pre></td></tr></table></figure><h4 id="全部输出"><a href="#全部输出" class="headerlink" title="全部输出"></a>全部输出</h4><p>“&amp;&gt;”：将标准输出和错误输出全部写入到文件中，覆盖原有内容<br>“&amp;&gt;&gt;”：将标准输出和错误输出全部写入到文件中，不覆盖原有内容，在末尾继续添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@freedom ~]# ls &amp;&gt;&gt;one</span><br><span class="line">[root@freedom ~]# cat one</span><br><span class="line">bash: freedom: 未找到命令...</span><br><span class="line">bash: justice: 未找到命令...</span><br><span class="line">anaconda-ks.cfg</span><br><span class="line">initial-setup-ks.cfg</span><br><span class="line">one</span><br><span class="line">公共</span><br><span class="line">模板</span><br><span class="line">视频</span><br><span class="line">图片</span><br><span class="line">文档</span><br><span class="line">下载</span><br><span class="line">音乐</span><br><span class="line">桌面</span><br></pre></td></tr></table></figure><h3 id="ln软连接"><a href="#ln软连接" class="headerlink" title="ln软连接"></a>ln软连接</h3><p>软链接也称为符号链接，类似于 windows 里的快捷方式，有自己的数据块，主要存放 了链接其他文件的路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s [原文件或目录][软链接名]#给原文件创建一个软链接</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">删除软链接： rm -rf 软链接名，而不是 rm -rf 软链接名/</span><br><span class="line">如果使用 rm -rf 软链接名/ 删除，会把软链接对应的真实目录下内容删掉</span><br><span class="line">查询：通过 ll 就可以查看，列表属性第 1 位是 l，尾部会有位置指向。</span><br></pre></td></tr></table></figure><h3 id="histort"><a href="#histort" class="headerlink" title="histort"></a>histort</h3><p>查看已经执行过历史命令</p><h2 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h2><h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p>显示当前时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">date （功能描述：显示当前时间）</span><br><span class="line">date +%Y （功能描述：显示当前年份）</span><br><span class="line">date +%m（功能描述：显示当前月份）</span><br><span class="line">date +%d （功能描述：显示当前是哪一天）</span><br><span class="line">date &quot;+%Y-%m-%d %H:%M:%S&quot; （功能描述：显示年月日时分秒）</span><br></pre></td></tr></table></figure><p>显示非当前时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date -d &#x27;1 days ago&#x27; （功能描述：显示前一天时间）</span><br><span class="line">date -d &#x27;-1 days ago&#x27; （功能描述：显示明天时间）</span><br></pre></td></tr></table></figure><p>设置系统时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -s &quot;2023-06-19 20:52:18&quot;</span><br></pre></td></tr></table></figure><h3 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h3><p>查看日历</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用法：</span><br><span class="line"> cal [选项] [[[日] 月] 年]</span><br></pre></td></tr></table></figure><p>参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">选项：</span><br><span class="line"> -1, --one        只显示当前月份(默认)</span><br><span class="line"> -3, --three      显示上个月、当月和下个月</span><br><span class="line"> -s, --sunday     周日作为一周第一天</span><br><span class="line"> -m, --monday     周一用为一周第一天</span><br><span class="line"> -j, --julian     输出儒略日</span><br><span class="line"> -y, --year       输出整年</span><br><span class="line"> -V, --version    显示版本信息并退出</span><br><span class="line"> -h, --help       显示此帮助并退出</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h3><p>添加用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd [option] 用户名 </span><br></pre></td></tr></table></figure><p>参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> -b, --base-dir BASE_DIR新账户的主目录的基目录</span><br><span class="line"> -c, --comment COMMENT         新账户的 GECOS 字段</span><br><span class="line"> -d, --home-dir HOME_DIR       新账户的主目录</span><br><span class="line"> -D, --defaults显示或更改默认的 useradd 配置</span><br><span class="line">-e, --expiredate EXPIRE_DATE  新账户的过期日期</span><br><span class="line"> -f, --inactive INACTIVE       新账户的密码不活动期</span><br><span class="line"> -g, --gid GROUP新账户主组的名称或 ID</span><br><span class="line"> -G, --groups GROUPS新账户的附加组列表</span><br><span class="line"> -h, --help                    显示此帮助信息并推出</span><br><span class="line"> -k, --skel SKEL_DIR使用此目录作为骨架目录</span><br><span class="line"> -K, --key KEY=VALUE           不使用 /etc/login.defs 中的默认值</span><br><span class="line"> -l, --no-log-init不要将此用户添加到最近登录和登录失败数据库</span><br><span class="line"> -m, --create-home创建用户的主目录</span><br><span class="line"> -M, --no-create-home不创建用户的主目录</span><br><span class="line"> -N, --no-user-group不创建同名的组</span><br><span class="line"> -o, --non-unique允许使用重复的 UID 创建用户</span><br><span class="line"> -p, --password PASSWORD加密后的新账户密码</span><br><span class="line"> -r, --system                  创建一个系统账户</span><br><span class="line"> -R, --root CHROOT_DIR         chroot 到的目录</span><br><span class="line"> -P, --prefix PREFIX_DIR       prefix directory where are located the /etc/* files</span><br><span class="line"> -s, --shell SHELL新账户的登录 shell</span><br><span class="line"> -u, --uid UID新账户的用户 ID</span><br><span class="line"> -U, --user-group创建与用户同名的组</span><br><span class="line"> -Z, --selinux-user SEUSER为 SELinux 用户映射使用指定 SEUSER</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h3><p>设置用户密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd [选项...] &lt;帐号名称&gt;</span><br></pre></td></tr></table></figure><p>选项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-k, --keep-tokens       保持身份验证令牌不过期</span><br><span class="line"> -d, --delete            删除已命名帐号的密码(只有根用户才能进行此操作)</span><br><span class="line"> -l, --lock              锁定指名帐户的密码(仅限 root 用户)</span><br><span class="line"> -u, --unlock            解锁指名账户的密码(仅限 root 用户)</span><br><span class="line"> -e, --expire            终止指名帐户的密码(仅限 root 用户)</span><br><span class="line"> -f, --force             强制执行操作</span><br><span class="line"> -x, --maximum=DAYS      密码的最长有效时限(只有根用户才能进行此操作)</span><br><span class="line"> -n, --minimum=DAYS      密码的最短有效时限(只有根用户才能进行此操作)</span><br><span class="line"> -w, --warning=DAYS      在密码过期前多少天开始提醒用户(只有根用户才能进行此操作)</span><br><span class="line"> -i, --inactive=DAYS     当密码过期后经过多少天该帐号会被禁用(只有根用户才能进行此操作)</span><br><span class="line"> -S, --status            报告已命名帐号的密码状态(只有根用户才能进行此操作)</span><br><span class="line"> --stdin                 从标准输入读取令牌(只有根用户才能进行此操作)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="x2F-etc-x2F-shadown"><a href="#x2F-etc-x2F-shadown" class="headerlink" title="&#x2F;etc&#x2F;shadown"></a>&#x2F;etc&#x2F;shadown</h3><p>用于存储 Linux 系统中用户的密码信息</p><p>同 &#x2F;etc&#x2F;passwd 文件一样，文件中每行代表一个用户，同样使用 “:” 作为分隔符，不同之处在于，每行用户信息被划分为 9 个字段。每个字段的含义如下：</p><p>用户名：加密密码：最后一次修改时间：最小修改时间间隔：密码有效期：密码需要变更前的警告天数：密码过期后的宽限时间：账号失效时间：保留字段</p><h4 id="用户名"><a href="#用户名" class="headerlink" title="用户名"></a>用户名</h4><p>同 &#x2F;etc&#x2F;passwd 文件的用户名有相同的含义。</p><h4 id="加密密码"><a href="#加密密码" class="headerlink" title="加密密码"></a>加密密码</h4><p>这里保存的是真正加密的密码。目前 Linux 的密码采用的是 SHA512 散列加密算法，原来采用的是 MD5 或 DES 加密算法。SHA512 散列加密算法的加密等级更高，也更加安全。</p><p>注意，这串密码产生的乱码不能手工修改，如果手工修改，系统将无法识别密码，导致密码失效。很多软件透过这个功能，在密码串前加上 “!”、”*” 或 “x” 使密码暂时失效。</p><p>所有伪用户的密码都是 “!!” 或 “*”，代表没有密码是不能登录的。当然，新创建的用户如果不设定密码，那么它的密码项也是 “!!”，代表这个用户没有密码，不能登录。</p><h4 id="最后一次修改时间"><a href="#最后一次修改时间" class="headerlink" title="最后一次修改时间"></a>最后一次修改时间</h4><p>此字段表示最后一次修改密码的时间，可是，为什么 root 用户显示的是 15775 呢？</p><p>这是因为，Linux 计算日期的时间是以 1970 年 1 月 1 日作为 1 不断累加得到的时间，到 1971 年 1 月 1 日，则为 366 天。这里显示 15775 天，也就是说，此 root 账号在 1970 年 1 月 1 日之后的第 15775 天修改的 root 用户密码。</p><p>那么，到底 15775 代表的是哪一天呢？可以使用如下命令进行换算：</p><p>[root@localhost ~]# date -d “1970-01-01 15775 days”<br>2013年03月11日 星期一 00:00:00 CST</p><p>可以看到，通过以上命令，即可将其换算为我们习惯的系统日期。</p><h4 id="最小修改时间间隔"><a href="#最小修改时间间隔" class="headerlink" title="最小修改时间间隔"></a>最小修改时间间隔</h4><p>最小修改间隔时间，也就是说，该字段规定了从第 3 字段（最后一次修改密码的日期）起，多长时间之内不能修改密码。如果是 0，则密码可以随时修改；如果是 10，则代表密码修改后 10 天之内不能再次修改密码。</p><p>此字段是为了针对某些人频繁更改账户密码而设计的。</p><h4 id="密码有效期"><a href="#密码有效期" class="headerlink" title="密码有效期"></a>密码有效期</h4><p>经常变更密码是个好习惯，为了强制要求用户变更密码，这个字段可以指定距离第 3 字段（最后一次更改密码）多长时间内需要再次变更密码，否则该账户密码进行过期阶段。<br>该字段的默认值为 99999，也就是 273 年，可认为是永久生效。如果改为 90，则表示密码被修改 90 天之后必须再次修改，否则该用户即将过期。管理服务器时，通过这个字段强制用户定期修改密码。</p><h4 id="密码需要变更前的警告天数"><a href="#密码需要变更前的警告天数" class="headerlink" title="密码需要变更前的警告天数"></a>密码需要变更前的警告天数</h4><p>与第 5 字段相比较，当账户密码有效期快到时，系统会发出警告信息给此账户，提醒用户 “再过 n 天你的密码就要过期了，请尽快重新设置你的密码！”。</p><p>该字段的默认值是 7，也就是说，距离密码有效期的第 7 天开始，每次登录系统都会向该账户发出 “修改密码” 的警告信息。</p><h4 id="密码过期后的宽限天数"><a href="#密码过期后的宽限天数" class="headerlink" title="密码过期后的宽限天数"></a>密码过期后的宽限天数</h4><p>也称为“口令失效日”，简单理解就是，在密码过期后，用户如果还是没有修改密码，则在此字段规定的宽限天数内，用户还是可以登录系统的；如果过了宽限天数，系统将不再让此账户登陆，也不会提示账户过期，是完全禁用。</p><p>比如说，此字段规定的宽限天数是 10，则代表密码过期 10 天后失效；如果是 0，则代表密码过期后立即失效；如果是 -1，则代表密码永远不会失效。</p><h4 id="账号失效时间"><a href="#账号失效时间" class="headerlink" title="账号失效时间"></a>账号失效时间</h4><p>同第 3 个字段一样，使用自 1970 年 1 月 1 日以来的总天数作为账户的失效时间。该字段表示，账号在此字段规定的时间之外，不论你的密码是否过期，都将无法使用！</p><p>该字段通常被使用在具有收费服务的系统中。</p><h4 id="保留"><a href="#保留" class="headerlink" title="保留"></a>保留</h4><p>这个字段目前没有使用，等待新功能的加入。</p><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>查看用户是否存在</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id [OPTION]... [USER]</span><br></pre></td></tr></table></figure><h3 id="cat-x2F-etc-x2F-passwd"><a href="#cat-x2F-etc-x2F-passwd" class="headerlink" title="cat  &#x2F;etc&#x2F;passwd"></a>cat  &#x2F;etc&#x2F;passwd</h3><p>查看创建了哪些用户</p><h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><p>切换用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su 用户名称#功能描述：切换用户，只能获得用户的执行权限，不能获得环境变量</span><br><span class="line">su -用户名称#功能描述：切换到用户并获得该用户的环境变量及执行权限</span><br></pre></td></tr></table></figure><h3 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h3><p>删除用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userdel 用户名#删除用户但是保存主目录</span><br><span class="line">userdel -r 用户名#删除用户和用户主目录</span><br></pre></td></tr></table></figure><h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3><p>查看登陆用户信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whoami#显示自身用户名称</span><br><span class="line">who am i#显示自身用户名称以及登陆时间</span><br></pre></td></tr></table></figure><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>设置普通用户具有root权限</p><h3 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h3><p>修改用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod 参数 用户名</span><br></pre></td></tr></table></figure><p>选项：</p><ul><li>-c 用户说明：修改用户的说明信息，即修改 &#x2F;etc&#x2F;passwd 文件目标用户信息的第 5 个字段；</li><li>-d 主目录：修改用户的主目录，即修改 &#x2F;etc&#x2F;passwd 文件中目标用户信息的第 6 个字段，需要注意的是，主目录必须写绝对路径；</li><li>-e 日期：修改用户的失效曰期，格式为 “YYYY-MM-DD”，即修改 &#x2F;etc&#x2F;shadow 文件目标用户密码信息的第 8 个字段；</li><li>-g 组名：修改用户的初始组，即修改 &#x2F;etc&#x2F;passwd 文件目标用户信息的第 4 个字段（GID）；</li><li>-u UID：修改用户的UID，即修改 &#x2F;etc&#x2F;passwd 文件目标用户信息的第 3 个字段（UID）；</li><li>-G 组名：修改用户的附加组，其实就是把用户加入其他用户组，即修改 &#x2F;etc&#x2F;group 文件；</li><li>-l 用户名：修改用户名称；</li><li>-L：临时锁定用户（Lock）；</li><li>-U：解锁用户（Unlock），和 -L 对应；</li><li>-s shell：修改用户的登录 Shell，默认是 &#x2F;bin&#x2F;bash。</li></ul><h2 id="用户组管理命令"><a href="#用户组管理命令" class="headerlink" title="用户组管理命令"></a>用户组管理命令</h2><h3 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h3><p>新建组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd 用户组名</span><br></pre></td></tr></table></figure><h3 id="groupdel"><a href="#groupdel" class="headerlink" title="groupdel"></a>groupdel</h3><p>删除组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel 用户组名</span><br></pre></td></tr></table></figure><h3 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h3><p>修改组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupmod 用户组明年</span><br></pre></td></tr></table></figure><p>选项：</p><ul><li>-g GID：修改组 ID；</li><li>-n 新组名：修改组名；</li></ul><h3 id="gpasswd"><a href="#gpasswd" class="headerlink" title="gpasswd"></a>gpasswd</h3><p>将系统用户加入或者移除群组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpasswd 选项 组名</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td></td><td>选项为空时，表示给群组设置密码，仅 root 用户可用。</td></tr><tr><td>-A user1,…</td><td>将群组的控制权交给 user1,… 等用户管理，也就是说，设置 user1,… 等用户为群组的管理员，仅 root 用户可用。</td></tr><tr><td>-M user1,…</td><td>将 user1,… 加入到此群组中，仅 root 用户可用。</td></tr><tr><td>-r</td><td>移除群组的密码，仅 root 用户可用。</td></tr><tr><td>-R</td><td>让群组的密码失效，仅 root 用户可用。</td></tr><tr><td>-a user</td><td>将 user 用户加入到群组中。</td></tr><tr><td>-d user</td><td>将 user 用户从群组中移除。</td></tr></tbody></table><h3 id="newgrp"><a href="#newgrp" class="headerlink" title="newgrp"></a>newgrp</h3><p>切换用户的有效群组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newgrp 组名</span><br></pre></td></tr></table></figure><h3 id="x2F-etc-x2F-group"><a href="#x2F-etc-x2F-group" class="headerlink" title="&#x2F;etc&#x2F;group"></a>&#x2F;etc&#x2F;group</h3><p>用户组配置文件，查看创建了那些用户组</p><p>各用户组中，还是以 “：” 作为字段之间的分隔符，分为 4 个字段，每个字段对应的含义为：</p><p>组名：密码：GID：该用户组中的用户列表</p><h4 id="组名"><a href="#组名" class="headerlink" title="组名"></a>组名</h4><p>也就是是用户组的名称，有字母或数字构成。同 &#x2F;etc&#x2F;passwd 中的用户名一样，组名也不能重复。</p><h4 id="组密码"><a href="#组密码" class="headerlink" title="组密码"></a>组密码</h4><p>和 &#x2F;etc&#x2F;passwd 文件一样，这里的 “x” 仅仅是密码标识，真正加密后的组密码默认保存在 &#x2F;etc&#x2F;gshadow 文件中。</p><p>不过，用户设置密码是为了验证用户的身份，那用户组设置密码是用来做什么的呢？用户组密码主要是用来指定组管理员的，由于系统中的账号可能会非常多，root 用户可能没有时间进行用户的组调整，这时可以给用户组指定组管理员，如果有用户需要加入或退出某用户组，可以由该组的组管理员替代 root 进行管理。但是这项功能目前很少使用，我们也很少设置组密码。如果需要赋予某用户调整某个用户组的权限，则可以使用 sudo 命令代替。</p><h4 id="组ID-GID"><a href="#组ID-GID" class="headerlink" title="组ID (GID)"></a>组ID (GID)</h4><p>就是群组的 ID 号，Linux 系统就是通过 GID 来区分用户组的，同用户名一样，组名也只是为了便于管理员记忆。</p><p>这里的组 GID 与 &#x2F;etc&#x2F;passwd 文件中第 4 个字段的 GID 相对应，实际上，&#x2F;etc&#x2F;passwd 文件中使用 GID 对应的群组名，就是通过此文件对应得到的。</p><h4 id="组中的用户"><a href="#组中的用户" class="headerlink" title="组中的用户"></a>组中的用户</h4><p>此字段列出每个群组包含的所有用户。需要注意的是，如果该用户组是这个用户的初始组，则该用户不会写入这个字段，可以这么理解，该字段显示的用户都是这个用户组的附加用户。</p><p>举个例子，lamp 组的组信息为 “lamp:x:502:”，可以看到，第四个字段没有写入 lamp 用户，因为 lamp 组是 lamp 用户的初始组。如果要查询这些用户的初始组，则需要先到 &#x2F;etc&#x2F;passwd 文件中查看 GID（第四个字段），然后到 &#x2F;etc&#x2F;group 文件中比对组名。</p><p>每个用户都可以加入多个附加组，但是只能属于一个初始组。所以我们在实际工作中，如果需要把用户加入其他组，则需要以附加组的形式添加。例如，我们想让 lamp 也加入 root 这个群组，那么只需要在第一行的最后一个字段加入 lamp，即 root:x:0:lamp 就可以了。</p><p>一般情况下，用户的初始组就是在建立用户的同时建立的和用户名相同的组。</p><h3 id="x2F-etc-x2F-gshadow"><a href="#x2F-etc-x2F-gshadow" class="headerlink" title="&#x2F;etc&#x2F;gshadow"></a>&#x2F;etc&#x2F;gshadow</h3><p>文件中，每行代表一个组用户的密码信息，各行信息用 “:” 作为分隔符分为 4 个字段，每个字段的含义如下：</p><p>组名：加密密码：组管理员：组附加用户列表</p><h4 id="组名-1"><a href="#组名-1" class="headerlink" title="组名"></a>组名</h4><p>同 &#x2F;etc&#x2F;group 文件中的组名相对应。</p><h4 id="组密码-1"><a href="#组密码-1" class="headerlink" title="组密码"></a>组密码</h4><p>对于大多数用户来说，通常不设置组密码，因此该字段常为空，但有时为 “!”，指的是该群组没有组密码，也不设有群组管理员。</p><h4 id="组管理员"><a href="#组管理员" class="headerlink" title="组管理员"></a>组管理员</h4><p>从系统管理员的角度来说，该文件最大的功能就是创建群组管理员。那么，什么是群组管理员呢？</p><p>考虑到 Linux 系统中账号太多，而超级管理员 root 可能比较忙碌，因此当有用户想要加入某群组时，root 或许不能及时作出回应。这种情况下，如果有群组管理员，那么他就能将用户加入自己管理的群组中，也就免去麻烦 root 了。</p><p>不过，由于目前有 sudo 之类的工具，因此群组管理员的这个功能已经很少使用了。</p><h4 id="组中的附加用户"><a href="#组中的附加用户" class="headerlink" title="组中的附加用户"></a>组中的附加用户</h4><p>该字段显示这个用户组中有哪些附加用户，和 &#x2F;etc&#x2F;group 文件中附加组显示内容相同。</p><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><h4 id="Linux文件权限详解"><a href="#Linux文件权限详解" class="headerlink" title="Linux文件权限详解"></a>Linux文件权限详解</h4><p>Linux系统中不仅是对用户与组根据UID,GID进行了管理，还对Linux系统中的文件，按照用户与组进行分类，针对不同的群体进行了权限管理，用他来确定谁能通过何种方式对文件和目录进行访问和操作。</p><p><img src="https://s2.loli.net/2022/04/30/kE3VYpnbLrejgKm.jpg" alt="文件权限"></p><h4 id="一、文件权限"><a href="#一、文件权限" class="headerlink" title="一、文件权限"></a>一、文件权限</h4><p>文件的权限针对三类对象进行定义</p><p>owner 属主，缩写u</p><p>group 属组，缩写g</p><p>other 其他，缩写o</p><p>每个文件针对每类访问者定义了三种主要权限</p><p>r：Read 读</p><p>w：Write 写</p><p>x：eXecute 执行</p><p>另 X：针对目录加执行权限，文件不加执行权限（因文件具备执行权限有安全隐患）</p><p>注意：root账户不受文件权限的读写限制，执行权限受限制</p><p>对于文件和目录来说，r，w，x有着不同的作用和含义：</p><p>针对文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r：读取文件内容</span><br><span class="line"></span><br><span class="line">w：修改文件内容</span><br><span class="line"></span><br><span class="line">x：执行权限对除二进制程序以外的文件没什么意义</span><br></pre></td></tr></table></figure><p>针对目录：目录本质可看做是存放文件列表、节点号等内容的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r：查看目录下的文件列表</span><br><span class="line"></span><br><span class="line">w：删除和创建目录下的文件</span><br><span class="line"></span><br><span class="line">x：可以cd进入目录，能查看目录中文件的详细属性，能访问目录下文件内容（基础权限）</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/30/c1G7jMqUwCKDmRx.png" alt="权限"></p><h4 id="二、chmod修改文件访问权限"><a href="#二、chmod修改文件访问权限" class="headerlink" title="二、chmod修改文件访问权限"></a>二、chmod修改文件访问权限</h4><p>方法一</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmod who option per file</span><br><span class="line">参数详解</span><br><span class="line">who：对象（u：owner属主 g：group属组 o：other其他 a：all全部）</span><br><span class="line">option：+ - =</span><br><span class="line">per:权限（r w x X）</span><br></pre></td></tr></table></figure><p>方法二</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chmod xxx file</span><br><span class="line">r:4</span><br><span class="line">w:2</span><br><span class="line">x:1</span><br></pre></td></tr></table></figure><h4 id="三、chown改变所有者"><a href="#三、chown改变所有者" class="headerlink" title="三、chown改变所有者"></a>三、chown改变所有者</h4><p>通过chown改变文件的拥有者和群组。在更改文件的所有者或所属群组时，可以使用用户名称和用户识别码设置。普通用户不能将自己的文件改变成其他的拥有者。其操作权限一般为管理员。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [选项] [最终用户] [文件或目录]</span><br></pre></td></tr></table></figure><p>参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">必要参数:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">　　　　-c 显示更改的部分的信息</span><br><span class="line">　　　　-f 忽略错误信息</span><br><span class="line">　　　　-h 修复符号链接</span><br><span class="line">　　　　-R 处理指定目录以及其子目录下的所有文件</span><br><span class="line">　　　　-v 显示详细的处理信息</span><br><span class="line">　　　　-deference 作用于符号链接的指向，而不是链接文件本身</span><br><span class="line">选择参数:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">　　--reference=&lt;目录或文件&gt; 把指定的目录/文件作为参考，把操作的文件/目录设置成参考文件/目录相同拥有者和群组</span><br><span class="line">　　--from=&lt;当前用户：当前群组&gt; 只有当前用户和群组跟指定的用户和群组相同时才进行改变</span><br><span class="line">　　--help 显示帮助信息</span><br><span class="line">　　--version 显示版本信息</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chown hjl:hjl txt#改变txt文件的拥有者为hjl群组为hjl</span><br><span class="line">chown  ：hjl txt#改变txt的群组为hjl</span><br><span class="line">chown -R -v root:mail test6#改变指定目录以及其子目录下的所有文件的拥有者和群组</span><br></pre></td></tr></table></figure><h4 id="四、chgrp改变所属组"><a href="#四、chgrp改变所属组" class="headerlink" title="四、chgrp改变所属组"></a>四、chgrp改变所属组</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [最终用户组] [文件或目录] </span><br></pre></td></tr></table></figure><h3 id="ACL权限"><a href="#ACL权限" class="headerlink" title="ACL权限"></a>ACL权限</h3><h4 id="ACL-是什么"><a href="#ACL-是什么" class="headerlink" title="ACL 是什么"></a>ACL 是什么</h4><p>ACL的全称是 Access Control List (访问控制列表) ，一个针对文件&#x2F;目录的访问控制列表。它在UGO权限管理的基础上为文件系统提供一个额外的、更灵活的权限管理机制。它被设计为UNIX文件权限管理的一个补充。ACL允许你给任何的用户或用户组设置任何文件&#x2F;目录的访问权限。</p><h4 id="设置ACL权限"><a href="#设置ACL权限" class="headerlink" title="设置ACL权限"></a>设置ACL权限</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setfacl</span><br></pre></td></tr></table></figure><p>选项：<br>-m 设定ACL权限 setfacl -m u(g):用户名(组名):权限 文件名<br>-x 删除某一用户和组的ACL权限，命令格式 : setfacl -x u(g):用户名(组名) 文件名<br>-b 删除所有的ACL权限<br>-d 设定默认的ACL权限,父目录下新建的文件都会继承此权限,命令格式：setfacl -m d:u:用户名:权限 文件名<br>-k 删除默认的ACL权限<br>-R 递归设定ACL权限,仅原本存在的文件会生效,命令格式 : setfacl -m u(g):用户名(组名):权限 -R 文件名</p><h2 id="搜索查找"><a href="#搜索查找" class="headerlink" title="搜索查找"></a>搜索查找</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>find 指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件显示在终端。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [搜索范围] [选项]</span><br></pre></td></tr></table></figure><h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h3><p>locate 指令利用事先建立的系统中所有文件名称及路径的 locate 数据库实现快速定位给 定的文件。</p><p>Locate 指令无需遍历整个文件系统，查询速度较快。</p><p>为了保证查询结果的准确 度，管理员必须定期更新 locate 时刻。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate 查找内容</span><br></pre></td></tr></table></figure><h3 id="grep和-管道符"><a href="#grep和-管道符" class="headerlink" title="grep和 | 管道符"></a>grep和 | 管道符</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep 选项 查找内容 源文件</span><br></pre></td></tr></table></figure><p>管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理</p><h2 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h2><h3 id="gzip-x2F-gunzip-压缩"><a href="#gzip-x2F-gunzip-压缩" class="headerlink" title="gzip&#x2F;gunzip 压缩"></a>gzip&#x2F;gunzip 压缩</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip 文件 #压缩文件，只能将文件压缩为*.gz文件</span><br><span class="line">gunzip 文件.gz#解压缩文件命令</span><br></pre></td></tr></table></figure><h3 id="zip-x2F-unzip压缩"><a href="#zip-x2F-unzip压缩" class="headerlink" title="zip&#x2F;unzip压缩"></a>zip&#x2F;unzip压缩</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip [选项] 文件.zip 将要压缩的内容#压缩文件和目录</span><br><span class="line">unzip [选项] 文件.zip#解压缩文件</span><br></pre></td></tr></table></figure><p>常用参数：</p><center><b>zip</b></center><table><thead><tr><th align="center">-m</th><th align="center">将文件压缩后，删除原文件</th></tr></thead><tbody><tr><td align="center">-o</td><td align="center">将压缩文件内的所有文件的最新变动时间设为压缩的时间</td></tr><tr><td align="center">-q</td><td align="center">安静模式，在压缩的时候不显示指令执行的过程</td></tr><tr><td align="center">-r</td><td align="center">递归压缩，将自定目录下的所有子文件以及文件一起处理</td></tr><tr><td align="center">-x</td><td align="center">”文件列表“，压缩时排除文件列表中的文件</td></tr></tbody></table><center><b>unzip</b></center><table><thead><tr><th align="center">-c</th><th align="center">将解压缩的结果显示到屏幕上（显示每一个目录下的每一个文件的内容），同时对字符做适当的转换，但是并没有解压压缩包</th></tr></thead><tbody><tr><td align="center">-l</td><td align="center">显示压缩文件内所包含的文件</td></tr><tr><td align="center">-t</td><td align="center">检查压缩文件是否正确</td></tr><tr><td align="center">-v</td><td align="center">执行时显示压缩文件的详细信息</td></tr><tr><td align="center">-q</td><td align="center">安静模式，执行时不显示任何信息</td></tr><tr><td align="center">-d</td><td align="center">指定文件解压后存储的目录</td></tr><tr><td align="center">-x</td><td align="center">指定不要处理压缩文件中的那些文件</td></tr></tbody></table><h3 id="tar打包"><a href="#tar打包" class="headerlink" title="tar打包"></a>tar打包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar [选项] XXX.tar.gz 将要打包进去的内容#打包目录，压缩后的文件格式.tar.gz</span><br></pre></td></tr></table></figure><p>常用参数：</p><ul><li>-A 新增压缩文件到已存在的压缩</li><li>-B 设置区块大小</li><li>-c 建立新的压缩文件</li><li>-d 记录文件的差别</li><li>-r 添加文件到已经压缩的文件</li><li>-u 添加改变了和现有的文件到已经存在的压缩文件</li><li>-x 从压缩的文件中提取文件</li><li>-t 显示压缩文件的内容</li><li>-z 支持gzip解压文件</li><li>-j 支持bzip2解压文件</li><li>-Z 支持compress解压文件</li><li>-v 显示操作过程</li><li>-l 文件系统边界设置</li><li>-k 保留原有文件不覆盖</li><li>-m 保留文件不被覆盖</li><li>-W 确认压缩文件的正确性</li></ul><p>可选参数如下：</p><ul><li>-b 设置区块数目</li><li>-C 切换到指定目录</li><li>-f 指定压缩文件</li><li>–help 显示帮助信息</li><li>–version 显示版本信息</li></ul><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><p>查看文件和目录占用的磁盘空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du 目录/文件</span><br></pre></td></tr></table></figure><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>查看磁盘空间使用情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df 选项</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>-a查看全部文件系统，单位默认KB</li><li>-h    以KB、MB、GB的单位来显示</li></ul><h3 id="lsblk"><a href="#lsblk" class="headerlink" title="lsblk"></a>lsblk</h3><p>显示设备挂载情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure><h3 id="mount-x2F-umount-挂载-x2F-卸载"><a href="#mount-x2F-umount-挂载-x2F-卸载" class="headerlink" title="mount&#x2F;umount 挂载&#x2F;卸载"></a>mount&#x2F;umount 挂载&#x2F;卸载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount [-t vfstype] [-o options] device dir#功能描述：挂载设备</span><br><span class="line">umount 设备文件名或挂载点 #功能描述：卸载设备</span><br></pre></td></tr></table></figure><h3 id="fdisk分区"><a href="#fdisk分区" class="headerlink" title="fdisk分区"></a>fdisk分区</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l#查看磁盘分区详情</span><br><span class="line">fdisk 磁盘设备名#对新增磁盘进行分区操作</span><br></pre></td></tr></table></figure><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>查看当前系统进程状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep xxx#查看系统中所有进程</span><br><span class="line">ps -ef | grep xxx#查看子父进程之间的关系</span><br></pre></td></tr></table></figure><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>终止进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill [选项] 进程号#通过进程号杀死进程</span><br><span class="line">killall 进程名称#通过进程名称杀死进程，支持通配符</span><br></pre></td></tr></table></figure><h3 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h3><p>查看进程树</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree [选项]</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>-A: 各进程树之间的连接以<a href="https://so.csdn.net/so/search?q=ASCII%E7%A0%81&spm=1001.2101.3001.7020">ASCII码</a>字符来连接</li><li>-U:各进程树之间的连接以utf8字符来连接，某些终端可能会有错误</li><li>-p:同时列出每个进程的PID</li><li>-u: 同时列出每个进程的所属账号名称：</li></ul><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>实时监控系统进程状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top [选项]</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>-d：number代表秒数，表示top命令显示的页面更新一次的间隔。默认是5秒。</li><li>-b：以批次的方式执行top。 </li><li>-n：与-b配合使用，表示需要进行几次top命令的输出结果。</li><li>-p：指定特定的pid进程号进行观察。</li></ul><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>显示网络状态和端口占用信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -anp | grep 进程号 #查看该进程网络信息</span><br><span class="line"></span><br><span class="line">netstat –nlp | grep 端口号 #查看网络端口号占用情况</span><br></pre></td></tr></table></figure><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p>VI 是 Unix 操作系统和类 Unix 操作系统中最通用的文本编辑器。</p><p>VIM 编辑器是从 VI 发展出来的一个性能更强大的文本编辑器。可以主动的以字体颜 色辨别语法的正确性，方便程序设计。VIM 与 VI 编辑器完全兼容。</p><h3 id="一般模式"><a href="#一般模式" class="headerlink" title="一般模式"></a>一般模式</h3><p>以 vi 打开一个档案就直接进入一般模式了（这是默认的模式）。</p><p>在这个模式中， 你可 以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档 案内容， 也可以使用『复制、粘贴』来处理你的文件数据。</p><table><thead><tr><th align="center">yy</th><th align="center">复制光标当前一行</th></tr></thead><tbody><tr><td align="center">y 数字 y</td><td align="center">复制一段（从第几行到第几行）</td></tr><tr><td align="center">p</td><td align="center">箭头移动到目的行粘贴</td></tr><tr><td align="center">u</td><td align="center">撤销上一步</td></tr><tr><td align="center">dd</td><td align="center">删除光标当前行</td></tr><tr><td align="center">d 数字 d</td><td align="center">删除光标（含）多少行</td></tr><tr><td align="center">x</td><td align="center">剪切一个字母，相当于del</td></tr><tr><td align="center">X</td><td align="center">剪切一个字母，相当于Backspace</td></tr><tr><td align="center">yw</td><td align="center">复制一个词</td></tr><tr><td align="center">dw</td><td align="center">删除一个词</td></tr><tr><td align="center">shift+6</td><td align="center">移动到行头</td></tr><tr><td align="center">shift+4</td><td align="center">移动到行尾</td></tr><tr><td align="center">1+shift+g</td><td align="center">移动到页头，数字</td></tr><tr><td align="center">shift+g</td><td align="center">移动到页尾</td></tr><tr><td align="center">数字+shift+g</td><td align="center">移动到目标行</td></tr></tbody></table><h3 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h3><p>在一般模式中可以进行删除、复制、粘贴等的动作，但是却无法编辑文件内容的！</p><p>要等到你按下『i, I, o, O, a, A』等任何一个字母之后才会进入编辑模式。</p><p>注意了！通常在Linux中，按下这些按键时，在画面的左下方会出现『INSERT或 REPLACE』的字样，此时才可以进行编辑。而如果要回到一般模式时， 则必须要按下 『Esc』这个按键即可退出编辑模式。</p><table><thead><tr><th align="center">按键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">i</td><td align="center">当前光标前</td></tr><tr><td align="center">a</td><td align="center">当前光标后</td></tr><tr><td align="center">o</td><td align="center">当前光标行的下一行 I</td></tr><tr><td align="center">A</td><td align="center">光标所在行最后</td></tr><tr><td align="center">O</td><td align="center">当前光标行的上一行</td></tr></tbody></table><p>按『<code>Esc</code>』键 退出编辑模式，之后所在的模式为一般模式。</p><h3 id="指令模式"><a href="#指令模式" class="headerlink" title="指令模式"></a>指令模式</h3><p>强制保存退出 ：wq!<br>在一般模式当中，输入『 : &#x2F; ?』3个中的任何一个按钮，就可以将光标移动到最底下那 一行。</p><p>在这个模式当中， 可以提供你『搜寻资料』的动作，而读取、存盘、大量取代字符、 离开 vi 、显示行号等动作是在此模式中达成的！</p><table><thead><tr><th align="center">:w</th><th align="center">保存</th></tr></thead><tbody><tr><td align="center">:q</td><td align="center">退出</td></tr><tr><td align="center">:!</td><td align="center">强制执行</td></tr><tr><td align="center">&#x2F;</td><td align="center">要查找的词</td></tr><tr><td align="center">n</td><td align="center">查找下一个，N 往上查找</td></tr><tr><td align="center">:noh</td><td align="center">取消高亮显示</td></tr><tr><td align="center">:set nu</td><td align="center">显示行号</td></tr><tr><td align="center">:set nonu</td><td align="center">关闭行号</td></tr><tr><td align="center">:%s&#x2F;old&#x2F;new&#x2F;g</td><td align="center">替换内容 &#x2F;g 替换匹配到的所有内容</td></tr></tbody></table><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><blockquote><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p><p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p><p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p></blockquote><h3 id="脚本格式"><a href="#脚本格式" class="headerlink" title="脚本格式"></a>脚本格式</h3><p>脚本以<code>#!/bin/bash</code> 开头（指定解析器）</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="系统预定义变量"><a href="#系统预定义变量" class="headerlink" title="系统预定义变量"></a>系统预定义变量</h4><p>常用系统变量 <code>$HOME</code>、<code>$PWD</code>、<code>$SHELL</code>、<code>$USER</code> 等</p><h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><ul><li>基本语法<ul><li>定义变量：变量名&#x3D;变量值（&#x3D;号前后不能有空格）</li><li>撤销变量：unset 变量名</li><li>声明静态变量：readonly 变量（不能unset)</li></ul></li><li>变量定义规则<ul><li>变量名称可以由字母、数字和下划线，但是不能以数字开头，环境变量名建议大写</li><li>等号两侧不能有空格</li><li>在bash中，变量默认类型都是字符串类型，无法直接进行数值运算</li><li>变量的值如果有空格，需要使用双引号或单引号括起来</li></ul></li></ul><h4 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h4><ul><li>$n （功能描述：n 为数字，$0 代表该脚本名称，$1-9 代 表 第 一 到 第 九 个 参 数 ， 十 以 上 的 参 数 ， 十 以 上 的 参 数 需 要 用 大 括 号 包 含 ， 如 9 代表第一到第九个参数，十以 上的参数，十以上的参数需要用大括号包含，如9代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如{10}）</li><li>$# （功能描述：获取所有输入参数个数，常用于循环,判断参数的个数是否正确以及 加强脚本的健壮性）。</li><li>$*（功能描述：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体）</li><li>$@ （功能描述：这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待）</li><li>$？ （功能描述：最后一次执行的命令的返回状态。如果这个变量的值为 0，证明上一 个命令正确执行；如果这个变量的值为非 0（具体是哪个数，由命令自己来决定），则证明 上一个命令执行不正确了。）</li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p><code>“$((运算式))” 或 “$[运算式]”</code></p><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><ol><li>test condition</li><li>[ condition ]（注意 condition 前后要有空格）</li></ol><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">（1）单分支 </span><br><span class="line"><span class="keyword">if</span> [ 条件判断式 ];<span class="keyword">then</span> </span><br><span class="line">程序 </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">或者 </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ 条件判断式 ] </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">程序 </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">（2）多分支 </span><br><span class="line"><span class="keyword">if</span> [ 条件判断式 ] </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">程序 </span><br><span class="line"><span class="keyword">elif</span> [ 条件判断式 ] </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">程序 </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">程序 </span><br><span class="line"><span class="keyword">fi</span> </span><br></pre></td></tr></table></figure><h4 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> $变量名 <span class="keyword">in</span> </span><br><span class="line"><span class="string">&quot;值 1&quot;</span>）</span><br><span class="line">如果变量的值等于值 1，则执行程序 1 </span><br><span class="line">;;</span><br><span class="line"><span class="string">&quot;值 2&quot;</span>）</span><br><span class="line">如果变量的值等于值 2，则执行程序 2 </span><br><span class="line">;; </span><br><span class="line">…省略其他分支… </span><br><span class="line">*） </span><br><span class="line">如果变量的值都不是以上的值，则执行此程序 </span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (( 初始值;循环控制条件;变量变化 ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">程序</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ 条件判断式 ] </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">程序 </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="read读取控制台输入"><a href="#read读取控制台输入" class="headerlink" title="read读取控制台输入"></a>read读取控制台输入</h3><p><code>read (选项) (参数)</code></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h4><h5 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h5><p><code>basename [string / pathname] [suffix]</code> （功能描述：basename 命令会删掉所有的前 缀包括最后一个（‘&#x2F;’）字符，然后将字符串显示出来。</p><h5 id="dirname"><a href="#dirname" class="headerlink" title="dirname"></a>dirname</h5><p><code>dirname 文件绝对路径</code> （功能描述：从给定的包含绝对路径的文件名中去除文件名 （非目录的部分），然后返回剩下的路径（目录的部分））</p><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] funname[()] </span><br><span class="line">&#123; </span><br><span class="line">Action; [<span class="built_in">return</span> int;] </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式使用单个字符串来描述、匹配一系列符合某个语法规则的字符串。</p><p>在很多文 本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。</p><p>在 Linux 中，grep， sed，awk 等文本处理工具都支持通过正则表达式进行模式匹配。</p><ul><li>^ 匹配一行的开头</li><li>$ 匹配一行的结束</li><li>. 匹配一个任意的字符</li></ul><ul><li>不单独使用，他和上一个字符连用，表示匹配上一个字符 0 次或多次</li><li>[ ]表示匹配某个范围内的一个字符</li><li>\ 表示转义，并不会单独使用。由于所有特殊字符都有其特定匹配模式，当我们想匹配 某一特殊符本身时（例如，我想找出所有包含 ‘$’ 的行），就会碰到困难。此时我们就要 将转义字符和特殊字符连用，来表示特殊字符本身</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="系统运维" scheme="https://github.com/HKingDragon/hkingdragon.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="Linux" scheme="https://github.com/HKingDragon/hkingdragon.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>FAT32系统</title>
    <link href="https://github.com/HKingDragon/hkingdragon.github.io/2022/04/26/FAT32%E7%B3%BB%E7%BB%9F/"/>
    <id>https://github.com/HKingDragon/hkingdragon.github.io/2022/04/26/FAT32%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-04-26T11:38:48.000Z</published>
    <updated>2022-04-26T11:41:01.094Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="FAT32系统"><a href="#FAT32系统" class="headerlink" title="FAT32系统"></a>FAT32系统</h1><h2 id="1-FAT32文件系统结构总览"><a href="#1-FAT32文件系统结构总览" class="headerlink" title="1.FAT32文件系统结构总览"></a>1.FAT32文件系统结构总览</h2><p>FAT32文件系统由DBR及其保留区、FAT1、FAT2、DATA区四个部分</p><p><img src="https://s2.loli.net/2022/04/26/OuRqJesxh16cbaV.png" alt="image-20220426193330987"></p><ol><li>DBR及其保留扇区：操作系统引导记录，DBR后有一些保留扇区</li><li>FAT1：文件分配表，FAT32一般有两份FAT,FAT1是第一个也是主FAT</li><li>FAT2：FAT1的备份</li><li>DATA:DATA数据区，FAT32主要区域，包含目录项</li></ol><h2 id="2-FAT32-DBR分析"><a href="#2-FAT32-DBR分析" class="headerlink" title="2.FAT32 DBR分析"></a>2.FAT32 DBR分析</h2><p>组成部分：跳转指令、OEM代号、BPB、引导程序和结束标志</p><ol><li><h3 id="跳转指令：将程序执行流程跳转到引导程序，计算跳转目录时是以该指令的下一个字节为基准"><a href="#跳转指令：将程序执行流程跳转到引导程序，计算跳转目录时是以该指令的下一个字节为基准" class="headerlink" title="跳转指令：将程序执行流程跳转到引导程序，计算跳转目录时是以该指令的下一个字节为基准"></a>跳转指令：将程序执行流程跳转到引导程序，计算跳转目录时是以该指令的下一个字节为基准</h3><p>EB 58 代表汇编语言额JMP 58 ，所以实际执行的下一条指令应位于5A，紧接着跳转指令的是一条空指令NOP（90H）</p></li><li><h3 id="OEM-代号：占用8字节，内容由创建该文件系统的OEM厂商安排。"><a href="#OEM-代号：占用8字节，内容由创建该文件系统的OEM厂商安排。" class="headerlink" title="OEM 代号：占用8字节，内容由创建该文件系统的OEM厂商安排。"></a>OEM 代号：占用8字节，内容由创建该文件系统的OEM厂商安排。</h3><p>OEM代号为”MSDOS5.0”说明这个FAT32分区是由微软的Windows 2000以上的操作系统格式化创建的</p></li><li><h3 id="BPB：FAT32-的BPB从DBR第12个字节处开始，占用7字节，记录了文件系统的重要信息"><a href="#BPB：FAT32-的BPB从DBR第12个字节处开始，占用7字节，记录了文件系统的重要信息" class="headerlink" title="BPB：FAT32 的BPB从DBR第12个字节处开始，占用7字节，记录了文件系统的重要信息"></a>BPB：FAT32 的BPB从DBR第12个字节处开始，占用7字节，记录了文件系统的重要信息</h3><p><img src="https://s2.loli.net/2022/04/26/Vhyd31nmurape2Y.png" alt="image-20220426193430807"></p></li></ol><p>​winhex模板查看文件系统信息</p><p>​<img src="https://s2.loli.net/2022/04/26/t4uRQTxWnFyNf8J.png" alt="image-20220426193453768"></p><p>常用信息：</p><ul><li>JMP instruction :跳转指令</li><li>OEM：OEM代号</li><li>Bytes per sector：每扇区字节数</li><li>Sectors per cluster：每簇扇区数</li><li>Reserved sectors：DBR保留扇区数(FAT1的开始扇区号)</li><li>Number of FATs：FAT表个数</li><li>Sectors per track：每FAT表扇区数</li><li>Root dir 1st duster：根目录首簇号</li><li>FSinfo setor：文件系统信息扇区号</li><li>Backup boot sector：DBR备份扇区号</li><li>File system：文件系统格式</li></ul><p>参数详细分析</p><ol><li><p>0BH~OCH:每扇区字节数</p><ul><li>记录每个扇区的大小，一般为512字节，512不是固定值，合法值包括512、1024、2048、4096</li></ul></li><li><p>ODH~ODH：每簇扇区数</p><ul><li>每簇扇区数记录着文件系统的簇大小，即由多少个扇区组成一个簇</li><li>FAT32最大支持128扇区的簇</li><li>在FAT32文件系统中所有的簇都从2号簇开始进行编写，所有簇都位于数据区内，在数据区之前时没有簇的</li></ul></li><li><p>0EH~0FH：DBR保留扇区数</p><ul><li>DBR保留扇区数是指DBR本身占用的扇区以及其后保留扇区的总和，也就是DBR到FAT1之间的是扇区总和，或者说是FAT1的开始扇区号</li><li>FAT32系统该值的取值范围是32扇区到38扇区之间</li></ul></li><li><p>10H~10H:FAT表的个数</p><ul><li>FAT表格式描述该文件系统有几个FAT表，一般FAT文件系统中都有两个FAT，即FAT1和FAT2,FAT2是FAT1的备份</li></ul></li><li><p>15H~15H：介质描述符</p></li></ol><ul><li>介质描述符是描述磁盘介质的参数，根据磁盘性质不同，取不同的值。</li></ul><ol start="6"><li><p>18H~19H：每磁道扇区数</p><ul><li>其值一般为255</li></ul></li><li><p>20H~23H：扇区总数</p><ul><li>扇区总数是指分区的总扇区数，也就是FAT32分区的大小</li></ul></li><li><p>24H~27H：每FAT扇区数</p><ul><li>记录FAT32分区中每个FAT表占用的扇区数</li></ul></li><li><p>28H~29H：标志</p><ul><li>表示FAT2是否可用，当其二进制最高位置为1时，表示只用FAT1可用，否则FAT2也可以用</li></ul></li><li><p>2AH~2BH：版本</p><ul><li>通常都为0</li></ul></li><li><p>2CH~2FH：根目录首簇号</p><ul><li>通常把数据区的第一个簇分配给根目录使用，也就是2号簇</li></ul></li><li><p>30H~31H：文件系统信息扇区号</p><ul><li><p>FAT32文件系统在DBR的保留扇区中安排了一个文件系统信息扇区，用以记录数据区中空闲簇的数量以及下一个空闲簇的簇号，该扇区一般在分区的1号扇区</p><p><img src="https://s2.loli.net/2022/04/26/4CztfPLlDAQGTeE.png" alt="image-20220426193610006"></p></li></ul></li><li><p>32H~33H：DBR备份扇区</p><ul><li>FAT32系统在DBR的保留扇区中安排了一个DBR的备份，一般在6号扇区，分区的第7个扇区。该备份扇区与原DBR扇区的内容和完全一样，如果原DBR遭到破坏，可以用备份扇区修复。</li></ul></li><li><p>40H~40H：BIOS驱动器号</p><ul><li>BIOS所描述的设备号码，一般把硬盘定义为8XH</li></ul></li><li><p>42H~42H:扩展引导标志</p><ul><li>扩展引导标记用来确认后面的三个参数是否有效，一般值为29H</li></ul></li><li><p>52H~59H：文件系统类型</p><ul><li>BPB的最后一个参数，直接用ASCII码记录当前分区的文件系统类型</li></ul></li></ol><h3 id="4-引导程序"><a href="#4-引导程序" class="headerlink" title="4.引导程序"></a>4.引导程序</h3><p>​FAT32的DBR引导扇区占用420字节（5AH~1FDH）</p><h3 id="5-结束标志"><a href="#5-结束标志" class="headerlink" title="5.结束标志"></a>5.结束标志</h3><p>​DBR、MBR、EBR的结束标志都相同为“55AA”</p><p><strong>以上五个部分共占用512字节，称它为DOS引导扇区。</strong></p><h2 id="3-FAT32文件系统的FAT表分析"><a href="#3-FAT32文件系统的FAT表分析" class="headerlink" title="3.FAT32文件系统的FAT表分析"></a>3.FAT32文件系统的FAT表分析</h2><h3 id="1-FAT表的特点"><a href="#1-FAT表的特点" class="headerlink" title="1.FAT表的特点"></a>1.FAT表的特点</h3><ol><li><p>每个FAT项的大小有32位（相当于4字节）</p></li><li><p>FAT32文件系统的FAT项是32为的，但是Windows系统只能用到26位。</p></li><li><p>系统能管理的簇大小可以达到128个扇区（64KB），FAT32最多可以管理的簇数位67108863，FAT32能够管理的分区大小为64*67108863&#x3D;4294967232KB&#x3D;4TB</p></li><li><p>FAT表中未使用的簇对应的FAT项用”00 00 00 00“，已经分配的簇号对应的FAT表项为”FF FF FF EF”,表示坏簇的表项为”FF FF FF F7”，文件结束簇为FF FF FF F8~FFFFFFFFF</p><table><thead><tr><th>表项值（12位）</th><th>表项值（16位）</th><th>表项值（32位）</th><th>簇描述信息含义</th></tr></thead><tbody><tr><td>000H</td><td>0000H</td><td>00000000H</td><td>“0”值（未分配使用）</td></tr><tr><td>001H–FEFH</td><td>0001–FFEFH</td><td>00000001–FFFFFFEFH</td><td>“一个簇号”（已占用）</td></tr><tr><td>FF0H–FF6H</td><td>FFF0–FFF6H</td><td>FFFFFFF0–FFFFFFF6H</td><td>保留</td></tr><tr><td>FF7H</td><td>FFF7H</td><td>FFFFFFF7H</td><td>坏簇</td></tr><tr><td>FF8H–FFFH</td><td>FFF8H–FFFFH</td><td>FFFFFFF8–FFFFFFFFH</td><td>“EOF”（文件结束簇）</td></tr></tbody></table></li></ol><h3 id="2-FAT表的实际应用"><a href="#2-FAT表的实际应用" class="headerlink" title="2.FAT表的实际应用"></a>2.FAT表的实际应用</h3><p>DBR所在分区，定位FAT1的步骤：</p><ol><li>系统通过该分区的分区表信息，定位到DBR扇区</li><li>读取DBR的BPB，通过读取OEH~OFH偏移出“DBR保留参数”这个参数</li><li>跳转到“DBR保留参数”这个扇区，就是FAT1表项的开始</li></ol><p><strong>格式化程序会把分配给FAT表的所有扇区都清零</strong></p><p>F8 FF FF 0F：F8表示介质类型为硬盘</p><p>DBR所在分区，定位备份FAT2的步骤：</p><ol><li>系统通过该分区的分区表信息，定位到DBR扇区</li><li>读取DBR的OEH~OFH偏移处，可以得到“DBR保留扇区数”</li><li>读取DBR的24H~27H偏移处，可以得到“每FAT扇区数”</li><li>FAT2的位置&#x3D;DBR保留扇区数+每FAT扇区数</li></ol><p>FAT2与FAT1的内容是相同的，FAT2是FAT1的备份</p><p><strong>如果FAT项为非零值，那么可能有三种情况：</strong></p><ul><li>FAT项映射的簇是一个不可用的坏簇，那么该FAT项中的值为坏簇标志（FFFFFFF7H）</li><li>FAT项映射的是某个文件的最后一个簇，那么该FAT项中的值为结束标志（FFFFFFOF)</li><li>该FAT项映射的簇被某个文件占用，但并不是文件的最后一个簇，那么该FAT项中的值是文件下一个簇的簇号</li></ul><h2 id="4-FAT32文件系统的数据区分析"><a href="#4-FAT32文件系统的数据区分析" class="headerlink" title="4.FAT32文件系统的数据区分析"></a>4.FAT32文件系统的数据区分析</h2><h3 id="数据区的位置"><a href="#数据区的位置" class="headerlink" title="数据区的位置"></a>数据区的位置</h3><ol><li>定位到DBR扇区</li><li>读取DBR的OEH~OFH偏移处，得到”DBR保留扇区”</li><li>读取DBR的24H~27H偏移处，得到”每FAT扇区数”</li><li>数据的位置&#x3D;DBR保留扇区数+2*每FAT扇区数</li></ol><h3 id="数据区的内容"><a href="#数据区的内容" class="headerlink" title="数据区的内容"></a>数据区的内容</h3><p>FAT32文件系统数据区的内容主要由三部分组成：根目录、子目录和文件内容。在数据区中是以“簇”为单位来管理这段空间。</p><h2 id="5-FAT32文件系统目录项分析"><a href="#5-FAT32文件系统目录项分析" class="headerlink" title="5.FAT32文件系统目录项分析"></a>5.FAT32文件系统目录项分析</h2><p>在FAT32文件系统下，分区根目录下的文件及文件夹的目录项存放在根目录区中，分区子目录下的文件及文件夹的目录项存放在子目录区中，根目录区和子目录区都在数据区中。</p><p>FAT32目录项可以分为四类：</p><ol><li><h3 id="短文件名目录项"><a href="#短文件名目录项" class="headerlink" title="短文件名目录项"></a>短文件名目录项</h3><p><img src="https://s2.loli.net/2022/04/26/Pg5jBxaoyLqR2h1.png" alt="image-20220426193655242"></p></li><li><h3 id="长文件名目录项"><a href="#长文件名目录项" class="headerlink" title="长文件名目录项"></a>长文件名目录项</h3><ol><li><p>系统取长文件名的前6个字符加上“~1”形成短文件名，扩展名不变</p></li><li><p>如果已存在这个名字的文件，则符号“~”后的数字自动增加</p></li><li><p>如果有非法的字符，则以下划线”_”替代</p></li><li><p>如果文件名很长，一个长文件就需要多个目录项，这些目录项按倒序排列在其短文件名目录项之前</p><p><img src="https://s2.loli.net/2022/04/26/LRBPeVDFjl1wv9m.png" alt="image-20220426193744723"></p><p>winhex模板显示</p><p>​<img src="https://s2.loli.net/2022/04/26/TLSk2RgCMxNlWfH.png" alt="image-20220426193758219"></p></li></ol><p></p></li><li><h3 id="“-”目录项和”-”目录项"><a href="#“-”目录项和”-”目录项" class="headerlink" title="“.”目录项和”..”目录项"></a>“.”目录项和”..”目录项</h3><ol><li><p>“.”表示当前目录</p><p>2E 20 20 20 20 20 20 20 20 20 20 3F 3F 3F 3F 3F </p><p>3F 3F 3F 3F 00 00 3F 3F 3F 3F 00 00 00 00 00 00</p></li><li><p>“..”表示上级目录</p><p>2E 2E 20 20 20 20 20 20 20 20 20 3F 3F 3F 3F 3F </p><p>3F 3F 3F 3F 00 00 3F 3F 3F 3F 00 00 00 00 00 00</p></li><li><p>卷标目录项</p><ol><li>对于FAT格式的分区，卷标的长度最多允许达到11字节，如果卷标为中文，则最多支持5个字符</li><li>卷标的目录项不记录起始簇号和大小</li><li>卷标的目录项不记录创建时间和最后访问时间，只记录修改时见&#x3D;间</li></ol></li></ol></li></ol><h2 id="6-FAT32文件系统根目录与子目录的管理"><a href="#6-FAT32文件系统根目录与子目录的管理" class="headerlink" title="6.FAT32文件系统根目录与子目录的管理"></a>6.FAT32文件系统根目录与子目录的管理</h2><h3 id="1-根目录的管理"><a href="#1-根目录的管理" class="headerlink" title="1.根目录的管理"></a>1.根目录的管理</h3><p>通过根目录找到文件的数据区：</p><ol><li>通过分区表定位分区一的开始位置，即该位置为这个分区的DBR扇区</li><li>通过”DBR保留扇区”、”每FAT扇区数”两个参数计算出根目录的开始扇区</li><li>通过文件名定位到目标文件的目录项，在目录中计算数据区所在的簇号</li><li>通过簇号转跳到数据区所在的扇区</li></ol><h3 id="2-子目录的管理"><a href="#2-子目录的管理" class="headerlink" title="2.子目录的管理"></a>2.子目录的管理</h3><ol><li>先找到根目录，根据根目录的簇号来定位到根目录的数据区</li><li>在根目录的数据区中搜索子目录的文件名</li><li>找到子目录的文件后再根据子目录的高低簇来找到子目录的数据区</li></ol><h2 id="7-FAT32文件系统删除文件分析"><a href="#7-FAT32文件系统删除文件分析" class="headerlink" title="7.FAT32文件系统删除文件分析"></a>7.FAT32文件系统删除文件分析</h2><h3 id="文件删除后的变化："><a href="#文件删除后的变化：" class="headerlink" title="文件删除后的变化："></a>文件删除后的变化：</h3><ul><li>文件目录项第一个字节被改为E5，文件名其他字节没有变化</li><li>文件高位簇2个字节清零</li><li>文件大小字节没有改变</li><li>文件FAT表的簇已经清零</li></ul><h3 id="文件删除后的恢复："><a href="#文件删除后的恢复：" class="headerlink" title="文件删除后的恢复："></a>文件删除后的恢复：</h3><p>​将被删除的文件的数据区的内容全部选中，并另存为一个新文件重命名即可将被删除的文件恢复出来。</p><h3 id="补充说明："><a href="#补充说明：" class="headerlink" title="补充说明："></a>补充说明：</h3><ul><li>如果文件在数据区中存放的位置比较靠后，文件起始簇号就会很大，那么文件目录项中记录文件起始簇号的高位两个字节就会有数据，当文件删除时，这两个字节会被清零，该文件的起始簇号值也就丢失了，这种删除的文件比较难恢复。</li><li>文件删除后，其FAT表中的簇链也会清零，如果文件有碎片，也就是不连续存放，这种删除的文件也比较难恢复。</li><li>文件删除后，虽然文件的内容并不会被清除，但其所占用的簇会释放，这些簇就很容易被其他文件进一步占用，这样就覆盖了被删除文件的数据，这种情况下的数据将无法恢复。</li></ul><h2 id="8-FAT32文件系统删除文件后目录项起始簇号高位清零的情况"><a href="#8-FAT32文件系统删除文件后目录项起始簇号高位清零的情况" class="headerlink" title="8.FAT32文件系统删除文件后目录项起始簇号高位清零的情况"></a>8.FAT32文件系统删除文件后目录项起始簇号高位清零的情况</h2><ul><li>将文件先放入回收站，在清空回收站，这种删除方法不清楚文件目录项中起始簇号高位的两个字节</li><li>将文件用shift+delete组合键直接彻底删除，这种删除方法将清除文件目录项中起始簇号高位的两个字节</li><li>将文件用shift+delete组合键直接彻底扇区，这种删除方法将清楚文件夹的目录项中起始簇号高位的两个字节，而文件夹里面的文件目录项起始簇号高位的两个字节并不清空。</li></ul><h3 id="文件目录项起始簇号高位清零后的恢复方法："><a href="#文件目录项起始簇号高位清零后的恢复方法：" class="headerlink" title="文件目录项起始簇号高位清零后的恢复方法："></a>文件目录项起始簇号高位清零后的恢复方法：</h3><ul><li><p>文件删除后，文件的创建时间，修改时间并不改变，所以可以寻找与被删除文件创建时间十分相近的文件，参考他们的起始簇号高位的两个字节</p></li><li><p>穷举法：</p><ol><li><p>点击被删除文件然后将文件所在的扇区号进行复制，再将复制的扇区号复制到跳至扇区扇区的位置，然后下面簇的框中显示的就是低位簇的结果。</p></li><li><p>用假设法假设高位簇为1，那么就是1乘以65563等于65536（注：每加一个簇那么就要在原有的基础上再加一个1乘以65536，以此类推）</p><p>高位簇公式：用低位簇的数值加上假设的数（注：再假设高位簇的时候只能在原有的1x65536上叠加一个1x65536）。例如：低位簇为：18344       高位簇假设为1那么高位簇就是1x65536；18344+65536&#x3D;83880；  如果假设高位簇为2，那么就是83880+1x65536&#x3D;149416就这样以此类推直到找到为止</p></li><li><p>将算出的结果复制到跳至扇区簇的框中进行跳转看是否在这个簇里面，如果没有在里面，那么再找下一个簇。（注：我们在这里算出的结果是簇的结果而不是扇区的）。</p></li><li><p>找到后将数据提取出来就可以了（注：如果要它的字节数，那么就用字符转换器将汉字会英文转换成十六进制，然后查找到后，到1C位置查看字节数）。</p></li></ol></li></ul><h2 id="9-FAT32文件系统误格式化的分析"><a href="#9-FAT32文件系统误格式化的分析" class="headerlink" title="9.FAT32文件系统误格式化的分析"></a>9.FAT32文件系统误格式化的分析</h2><h3 id="格式化后数据的变化："><a href="#格式化后数据的变化：" class="headerlink" title="格式化后数据的变化："></a>格式化后数据的变化：</h3><ul><li>FAT表除了0号FAT项、1号FAT项和2号FAT项以外已被完全清空</li><li>根目录项被完全清零</li><li>子目录项的下的文件的目录项还存在</li></ul><h3 id="格式化之后的文件恢复方法："><a href="#格式化之后的文件恢复方法：" class="headerlink" title="格式化之后的文件恢复方法："></a>格式化之后的文件恢复方法：</h3><ol><li>找到子目录下文件的目录项</li><li>计算文件的簇号</li><li>根据簇号跳转到扇区，即可找到文件的数据区</li><li>选择跟文件大小相同的字节，选择另外保存，即可将文件恢复</li></ol><h2 id="10-FAT32系统DBR破坏的恢复"><a href="#10-FAT32系统DBR破坏的恢复" class="headerlink" title="10.FAT32系统DBR破坏的恢复"></a>10.FAT32系统DBR破坏的恢复</h2><p>系统提示分区未格式化，显然是文件系统遭到破坏，winhex无法打开分区，可以断定DBR一定有错误。可以使用winhex打开分区所在的硬盘，然后跳转到该硬盘的DBR扇区。</p><h3 id="恢复方法："><a href="#恢复方法：" class="headerlink" title="恢复方法："></a>恢复方法：</h3><p>FAT32分区的DBR有一个备份，在分区的6号扇区，只要把这个备份找到并且复制过来就可以了。</p><h2 id="11-FAT32分区文件乱码的手工恢复"><a href="#11-FAT32分区文件乱码的手工恢复" class="headerlink" title="11.FAT32分区文件乱码的手工恢复"></a>11.FAT32分区文件乱码的手工恢复</h2><h3 id="数据丢失的原因："><a href="#数据丢失的原因：" class="headerlink" title="数据丢失的原因："></a>数据丢失的原因：</h3><p>文件系统把不是目录项的数据当成目录项读取。打开分区只能看到乱码</p><h3 id="数据恢复的思路和方法"><a href="#数据恢复的思路和方法" class="headerlink" title="数据恢复的思路和方法"></a>数据恢复的思路和方法</h3><p>思路：手工建一个目录项，指向用户的子目录</p><p>方法一：</p><p>搜索这些文件的目录项，找到它们的子目录。</p><p>方法二：</p><ol><li><p>点击文件夹所在的数据区</p></li><li><p>数据区内的数据显示的是一堆乱码（子目录和父目录的正常格式：子目录开头用2E 20 20 20 20 20 20 20 20 20 20开头；父目录用2E 2E 20 20 20 20 20 20 20 20 20 开头）</p></li><li><p>看文件夹在哪个簇号的方法：点击变成乱码的文件夹，然后将文件夹所在的扇区号复制到跳至扇区的框中，下面的结果就是为文件夹所在的簇号</p></li><li><p>然后将簇号放到计算器中将十进制转换为十六进制</p></li><li><p>搜索父目录在2B 7C的所有父目录 方法：找一个部分为0的扇区将它们填为“2E 2E 20 20 20 20 20 20 20 20 20 3F 3F 3F 3F 3F 3F 3F 3F 3F 00 00 3F 3F 3F 3F 7C 2B”（注：因为在winhex中的数值与外界的数值是相反的；又因为数值是从低位簇开始填写的，所以这里高位簇为0）。</p><p>7C 2B为高位簇</p></li><li><p>复制选块为十六进制，在查找十六进制数值里进行搜索–勾上通配符、全部搜索、偏移条件：512&#x3D;32，列出搜索结果</p></li><li><p>将搜索到的子目录高低位簇做记录</p></li><li><p>然后点击变乱码的文件夹将文件夹的数据区清零，然后再将虚拟的子目录复制到文件夹的数据区中，再将记录好的高低位簇填入到虚拟子目录中</p></li></ol><p>如果文件直接在根目录下或者直接在变成乱码的文件中，恢复方式：</p><p>1.搜索文件的开头4个字节</p><p>2.复制开头的4个字节粘贴到查找16进制数值里面去搜索</p><p>3.搜索到后将数据提取出来就可以了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据恢复" scheme="https://github.com/HKingDragon/hkingdragon.github.io/categories/%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D/"/>
    
    
    <category term="文件系统" scheme="https://github.com/HKingDragon/hkingdragon.github.io/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>NTFS文件系统</title>
    <link href="https://github.com/HKingDragon/hkingdragon.github.io/2022/04/26/NTFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://github.com/HKingDragon/hkingdragon.github.io/2022/04/26/NTFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-04-26T10:07:55.000Z</published>
    <updated>2022-05-03T06:39:22.466Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=530 height=450 src="https://music.163.com/outchain/player?type=0&id=3136952023&auto=1&height=430"></iframe><h1 id="NTFS文件系统"><a href="#NTFS文件系统" class="headerlink" title="NTFS文件系统"></a>NTFS文件系统</h1><h2 id="NTFS文件系统基本介绍"><a href="#NTFS文件系统基本介绍" class="headerlink" title="NTFS文件系统基本介绍"></a>NTFS文件系统基本介绍</h2><p><a href="https://www.dgxue.com/huifu/tag/ntfs/">NTFS</a><a href="https://www.dgxue.com/huifu/tag/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">文件系统</a>是随着Windows NT操作系统的诞生而产生的，并随着Windows NT 4跨入主力文件系统的行列。它的优点是安全性和稳定性极其出色，在使用中不易产生文件碎片；同时它还提供了容错结构日志，可以将用户的操作全部记录下来，从而保护了系统的安全。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><p>安全性</p></li><li><p>可恢复性</p></li><li><p>文件压缩</p></li><li><p>磁盘配额</p></li><li><p>B+树的文件管理</p><p>NTFS利用B＋树文件管理方法来跟踪文件在磁盘上的位置。在NTFS中文件名顺序存放，因而查找速度更快。如果卷比较大，B＋树会在宽度上增长，而不会在深度上增长，因此，当目录增大时，NTFS并没有显示出明显的性能下降。</p><p><img src="https://s2.loli.net/2022/04/26/U1sfOPLvzZxtaFm.png" alt="image-20220425090847401"></p></li></ol><h2 id="NTFS文件系统结构总览"><a href="#NTFS文件系统结构总览" class="headerlink" title="NTFS文件系统结构总览"></a>NTFS文件系统结构总览</h2><p>NTFS分区也被称为NTFS卷，卷上簇的大小，又称为卷因子，其大小是用户在创建NTFS卷时确定的。簇的大小一定是扇区大小的整数倍，通常是2n（n为整数）。</p><center><b>NTFS卷大小和簇大小关系表</b></center><table><thead><tr><th>卷大小（MB）</th><th>每簇的扇区</th><th>默认的簇大小</th></tr></thead><tbody><tr><td>≤512</td><td>1</td><td>512个字节</td></tr><tr><td>513～1024</td><td>2</td><td>1024个字节（1KB）</td></tr><tr><td>1025～2048</td><td>4</td><td>2048个字节（2KB）</td></tr><tr><td>≥2049</td><td>8</td><td>4KB</td></tr></tbody></table><p>NTFS文件系统使用了逻辑簇号（Logical Cluster Number，LCN）和虚拟簇号（Virtual Cluster Number，VCN）对卷进行管理。LCN是对卷的第一个簇到最后一个簇进行编号，只要知道LCN号和簇的大小以及NTFS卷在物理磁盘中的起始扇区（绝对扇区）就可以对簇进行定位，而这些信息在NTFS卷的引导扇区中可以找到（BPB参数）。找到簇在磁盘中的物理位置的计算公式是：</p><center>每簇扇区数×簇号＋卷的隐含扇区数（卷之前的扇区总数）＝簇的起始绝对扇区号</center><p>虚拟簇号（VCN）则是将特定文件的簇从头到尾进行编号，这样做的原因是方便系统对文件中的数据进行引用，VCN并不要求在物理上是连续的，要确定VCN的磁盘上的定位需先将其转换为LCN。</p><p>NTFS的第一个扇区为引导扇区，即DBR扇区。</p><p>在分区的第一个扇区（引导扇区DBR）后是15个扇区的NTLDR区域，这16个扇区共同构成$BOOT文件。在NTLDR后（但不一定是物理上相连的）是主文件表（Master File Table，MFT）区域，主文件表由文件记录构成，每个文件记录占2个扇区，文件记录简称为FR（File Record）。在FAT文件系统中是通过FAT表和文件目录项存储文件数据和记录文件的文件名、扩展名、建立时间、访问时间、修改时间、文件属性、文件大小、文件在磁盘中所占用的簇等信息进行管理的，而在NTFS文件系统中这些信息被称为属性，包括文件的内容在NTFS中也称为属性，各种属性被放入文件记录中进行管理。</p><p>NTFS文件系统的主文件表中还记录了一些非常重要的系统数据，这些数据被称为元数据（metadata）文件，简称为“元文件”，其中包括了用于文件定位和恢复的数据结构、引导程序数据及整个卷的分配位图等信息。NTFS文件系统将这些数据都当作文件进行管理，这些文件用户是不能访问的，它们的文件名的第一个字符都是“$”，表示该文件是隐藏的。在NTFS文件系统中，这样的文件主要有16个。</p><ul><li>MFT本身（$Mft）</li><li>MFT镜像（$MftMirr）</li><li>日志文件（$LogFile）</li><li>卷文件（$Volume）</li><li>属性定义表（$AttrDef）</li><li>根目录（$Root）</li><li>位图文件（$Bitmap）</li><li>引导文件（$Boot）</li><li>坏簇文件（$BadClus）</li><li>安全文件（$Secure）</li><li>大写文件（$UpCase）</li><li>扩展元数据文件（$Extended metadata directory）</li><li>重解析点文件（$Extend&#x2F;$Reparse）</li><li>变更日志文件（$Extend&#x2F;$UsnJrnl）</li><li>配额管理文件（$Extend&#x2F; $Quota）</li><li>对象ID文件（$Extend&#x2F;$ObjId）等</li></ul><p>这16个元数据文件总是占据着MFT的前16项记录，在这16项以后就是用户建立的文件和文件夹的记录了。</p><p>每个文件记录在主文件表中占据的磁盘空间一般为1KB，也就是两个扇区，NTFS文件系统分配给主文件表的区域大约占据了磁盘空间的12.5％，剩余的磁盘空间用来存放其他元文件和用户的文件。</p><center><b>NTFS文件系统的大致结构</b></center><p><img src="https://s2.loli.net/2022/04/26/pY6X2TnhNEiKu5I.png" alt="image-20220425091814165"></p><p><b>注：在NTFS文件系统所在分区的最后一个扇区是DBR的备份，但该扇区并不属于NTFS文件系统。</b></p><h2 id="NTFS文件系统引导扇区分析"><a href="#NTFS文件系统引导扇区分析" class="headerlink" title="NTFS文件系统引导扇区分析"></a>NTFS文件系统引导扇区分析</h2><p><a href="https://www.dgxue.com/huifu/tag/ntfs/">NTFS</a>文件系统的<a href="https://www.dgxue.com/huifu/tag/%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA/">引导扇区</a>是$Boot的第一个扇区，它的结构与FAT文件系统的DBR类似，所以习惯上也称该扇区为DBR扇区。DBR扇区在操作系统的引导过程起着非常重要的作用，如果这个扇区遭到破坏，系统将不能正常启动。</p><p>NTFS文件系统的DBR扇区与FAT文件系统的结构一样，也包括跳转指令、OEM代号、BPB参数、引导程序和结束标志。</p><center><b>NTFS文件系统的DBR扇区</b></center><p><img src="https://s2.loli.net/2022/04/26/fcJlYXUVZjG8m2i.png" alt="image-20220425092102932"></p><h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><p>跳转指令本身占用2字节，它将程序执行流程跳转到引导程序处。例如，当前DBR中的“EB 52”，就是代表汇编语言的“JMP 52”。</p><blockquote><p>注意：该指令本身占用2字节，计算跳转目标地址时以该指令的下一字节为基准，所以实际执行的下一条指令应该位于54H。紧接着跳转指令的是一条空指令NOP（90H）。</p></blockquote><h3 id="OEM代号"><a href="#OEM代号" class="headerlink" title="OEM代号"></a>OEM代号</h3><p>这部分占8字节，其内容由创建该文件系统的OEM厂商具体安排。例如，微软的Windows系统将此处直接设置为“NTFS”，在NTFS文件系统中也称为“文件系统ID”。</p><h3 id="BPB（BIOS参数块）"><a href="#BPB（BIOS参数块）" class="headerlink" title="BPB（BIOS参数块）"></a>BPB（BIOS参数块）</h3><p>BPB是BIOS Parameter Block的缩写，其含义为BIOS参数块。BPB从DBR的第12（0BH偏移处）个字节开始，到偏移53H结束，占用73个字节，记录了有关该文件系统的重要信息</p><center><b>NTFS文件系统BPB参数的含义</b></center><p><img src="https://s2.loli.net/2022/04/26/FoIJQZyYUHk1KXa.png" alt="image-20220425104726046"></p><center><b>NTFS的DBR参数模板</b></center><p><img src="https://s2.loli.net/2022/04/26/tiCPvyuVW3JhpBd.png" alt="image-20220425104820856"></p><ol><li>0BH～0CH：每扇区字节数</li></ol><p>​每扇区字节数记录每个逻辑扇区的大小，其常见值为512字节，但512并不是固定值，该值可以由程序定义，合法值包括512字节、1024字节、2048字节和4096字节。</p><ol start="2"><li>0DH～0DH：每簇扇区数</li></ol><p>​每簇扇区数记录着文件系统的簇大小，即由多少个扇区组成一个簇。</p><p>​如果这个分区是在系统安装前被格式化而来的，一般大于2GB的分区每簇默认占用8个扇区，也就是每簇大小为4KB，这个字节的内容就为十六进制值“08”。如果这个分区是由一个FAT分区转换而来，则每个簇一般占用1个扇区的空间，也就是每簇大小为512字节，这个字节的内容就是“01H”。</p><p>​在NTFS文件系统中所有的簇从0开始进行编号，每个簇都有一个自己的地址编号，并且从分区的第一个扇区就开始编簇。</p><ol start="3"><li>0EH～0FH：DBR保留扇区数</li></ol><p>​NTFS文件系统中DBR没有保留扇区，该值常为“0000”。</p><ol start="4"><li>10H～12H：总是0</li></ol><p>​这3个字节总是“00 00 00”。</p><ol start="5"><li>13H～14H：未用</li></ol><p>​这两个字节不用。</p><ol start="6"><li>15H～15H：介质描述符</li></ol><p>​这个字节为介质描述字节，一般硬盘为“F8H”；双面5.25英寸软盘为“F9H”；双面3.5英寸软盘RAM虚拟盘为“FAH”；3.5英寸、1.44MB的软盘一般为“F0H”。因为NTFS分区一定在硬盘上，所以此处常为16进制数“F8”。</p><ol start="7"><li>16H～17H：未用</li></ol><p>​这两个字节不用。</p><ol start="8"><li>18H～19H：每磁道扇区数</li></ol><p>​这是逻辑C&#x2F;H&#x2F;S中的一个参数，其值一般为63，NTFS已经不用此参数。</p><ol start="9"><li>1AH～1BH：磁头数</li></ol><p>​这是逻辑C&#x2F;H&#x2F;S中的一个参数，其值一般为255，NTFS已经不用此参数。</p><ol start="10"><li>1CH～1FH：隐藏扇区数</li></ol><p>​隐藏扇区数是指本分区之前使用的扇区数，该值与分区表中所描述的该分区的起始扇区号一致。对于主磁盘分区来讲，是MBR到该分区DBR之间的扇区数；对于扩展分区中的逻辑驱动器来讲，是其EBR到该分区DBR之间的扇区数。</p><ol start="11"><li>20H～23H：未用</li></ol><p>​这4字节不用。</p><ol start="12"><li>24H～27H：未用</li></ol><p>​这4字节不用，但总为80008000。</p><ol start="13"><li>28H～2FH：扇区总数</li></ol><p>​扇区总数是指分区的总扇区数。NTFS的BPB中记录的分区大小比分区表中记录的少一个扇区，因为分区最后一个扇区留给DBR备份使用了。</p><ol start="14"><li>30H～37H：$MFT的起始簇号</li></ol><p>​这8字节为$MFT的起始簇号，注意这个位置使用簇号定义的，而不是扇区号，并且该地址不是固定值。</p><ol start="15"><li>38H～3FH：$MFTMirr的起始簇号</li></ol><p>​这8字节为$MFTMirr的起始簇号，这个位置也使用簇号定义，而不是扇区号。$MFTMirr的地址也不是固定值的，可以在$MFT之后，也可以在$MFT之前。本例中，$MFTMirr的地址就在$MFT之前。</p><ol start="16"><li>40H～40H：文件记录的大小描述</li></ol><p>​这一个字节描述每个文件记录的簇数。注意该参数为带符号数，当其是负数时，说明每个文件记录的大小要小于每簇扇区数，在这种情况下，文件记录的大小用字节数表示，计算方法为：2-1×每个文件记录的簇数。例如，图4-401的DBR中该参数值为“F6H”，换算为十进制等于“-10”，所以每个文件记录的大小是2-1×-10＝210＝1024字节。</p><ol start="17"><li>41H～43H：未用</li></ol><p>​这3字节不用。</p><ol start="18"><li>44H～44H：索引缓冲的大小描述</li></ol><p>​这一个字节描述每个索引缓冲的簇数。注意该参数也是带符号数，当其是负数时，说明每个索引缓冲的大小要小于每簇扇区数，在这种情况下，索引缓冲的大小用字节数表示，计算方法为：2-1×每个索引缓冲的簇数。</p><ol start="19"><li>45H～47H：未用</li></ol><p>​这3字节不用。</p><ol start="20"><li>48H～4FH：卷序列号</li></ol><p>​这8字节为分区的逻辑序列号，也就是在命令行下输入DIR命令后显示的一排数据，这个序列号是硬盘格式化时随机产生的。</p><ol start="21"><li>50H～51H：校验和</li></ol><p>​BPB的最后四个字节是其校验和，一般都为0。</p><h3 id="引导程序"><a href="#引导程序" class="headerlink" title="引导程序"></a>引导程序</h3><p>NTFS的DBR引导程序占用426字节（54H～1FDH），其负责完成将系统文件NTLDR装入。对于一个没有安装操作系统的分区来讲，这段程序没有用处。</p><h3 id="结束标志"><a href="#结束标志" class="headerlink" title="结束标志"></a>结束标志</h3><p>NTFS的DBR引导程序占用426字节（54H～1FDH），其负责完成将系统文件NTLDR装入。对于一个没有安装操作系统的分区来讲，这段程序没有用处。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>以上5个部分共占用512字节，正好是1个扇区，这个扇区属于$BOOT文件的组成部分。该部分的内容中除了第5部分结束标志是固定不变之外，其余4部分都是不完全确定的，都因操作系统版本的不同而不同，也因硬盘的逻辑盘参数的变化而变化。</p></blockquote><h2 id="元文件-MFT分析"><a href="#元文件-MFT分析" class="headerlink" title="元文件$MFT分析"></a>元文件$MFT分析</h2><h3 id="NTFS文件系统的元文件"><a href="#NTFS文件系统的元文件" class="headerlink" title="NTFS文件系统的元文件"></a>NTFS文件系统的元文件</h3><p>在NTFS文件系统中，元文件主要有16个，包括MFT（<a href="https://www.dgxue.com/huifu/tag/mft/">$MFT</a>）、MFT镜像（$MFTMirr）、日志文件（$LogFile）、卷文件（$Volume）、属性定义表（$AttrDef）、根目录（$Root）、位图文件（$Bitmap）、引导文件（$Boot）、坏簇文件（$BadClus）、安全文件（$Secure）、大写文件（$UpCase）、扩展元数据文件（$Extended metadata directory）、重解析点文件（$Extend&#x2F;$Reparse）、变更日志文件（$Extend&#x2F;$UsnJrnl）、配额管理文件（$Extend&#x2F; $Quota）、对象ID文件（$Extend&#x2F;$ObjId）等，表4-30详细列出了这些元文件及它们的作用。</p><center><b>NTFS文件系统的元文件</b></center><table><thead><tr><th align="center">序号</th><th align="center">元文件</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">$MFT</td><td align="center">主文件表本身，是每个文件的索引</td></tr><tr><td align="center">1</td><td align="center">$MFTMirr</td><td align="center">主文件表的部分镜像</td></tr><tr><td align="center">2</td><td align="center">$LogFile</td><td align="center">事务型日志文件</td></tr><tr><td align="center">3</td><td align="center">$Volume</td><td align="center">卷文件，记录卷标等信息</td></tr><tr><td align="center">4</td><td align="center">$AttrDef</td><td align="center">属性定义列表文件</td></tr><tr><td align="center">5</td><td align="center">$Root</td><td align="center">根目录文件，管理根目录</td></tr><tr><td align="center">6</td><td align="center">$Bitmap</td><td align="center">位图文件，记录了分区中簇的使用情况</td></tr><tr><td align="center">7</td><td align="center">$Boot</td><td align="center">引导文件，记录了用于系统引导的数据情况</td></tr><tr><td align="center">8</td><td align="center">$BadClus</td><td align="center">坏簇列表文件</td></tr><tr><td align="center">9</td><td align="center">$Quota（NTFS4）</td><td align="center">在早期的Windows NT系统中此文件为磁盘配额信息</td></tr><tr><td align="center">10</td><td align="center">$Secure</td><td align="center">安全文件</td></tr><tr><td align="center">11</td><td align="center">$UpCase</td><td align="center">大小写字符转换表文件</td></tr><tr><td align="center">12</td><td align="center">$Extend metadata directory</td><td align="center">扩展元数据目录</td></tr><tr><td align="center">13</td><td align="center">$Extend&#x2F;$Reparse</td><td align="center">重解析点文件</td></tr><tr><td align="center">14</td><td align="center">$Extend&#x2F;$UsnJrnl</td><td align="center">加密日志文件</td></tr><tr><td align="center">15</td><td align="center">$Extend&#x2F;$Quota</td><td align="center">配额管理文件</td></tr><tr><td align="center">16</td><td align="center">$Extend&#x2F;$ObjId</td><td align="center">对象ID文件</td></tr></tbody></table><h3 id="MFT文件介绍"><a href="#MFT文件介绍" class="headerlink" title="$MFT文件介绍"></a>$MFT文件介绍</h3><p>在NTFS文件系统中，磁盘上的所有数据都是以文件的形式出现的，即使是文件系统的管理信息也是以一组文件的形式存储的，即元文件。16个元文件中主文件表（$MFT）是一个非常重要的元文件，它由文件记录构成，每个文件记录占用2个扇区。</p><p>每个文件都有一个文件记录，包括元文件本身，而主文件表（$MFT）就是专门用来存储文件记录的一个元文件，在$MFT中前16个文件记录总是元文件的纪录。</p><p>由于$MFT文件本身的重要性，为了确保文件系统结构的可靠性，系统专门为它准备了一个镜像文件（$MFTMirr），也就是$MFT中的第2个记录。</p><p>$MFT中前16个文件记录总是元文件的记录，并且这16个文件记录的顺序是固定的，下面对这16个记录简单做一个介绍：</p><p>第1个记录就是$MFT自身的记录，也就是说$MFT首先对自己进行管理。</p><p>第2个记录是$MFTMirr的记录，也就是$MFT前4个文件记录的镜像。</p><p>第3个记录是日志文件（$LogFile）的记录，该文件是NTFS为实现可恢复性和安全性而设计的。当系统运行时，NTFS就会在日志文件中记录所有影响NTFS卷结构的操作，包括文件的创建和改变目录结构的命令，从而可在系统失败时能够恢复NTFS卷。</p><p>第4个记录是卷文件（$Volume）的记录，它包含卷名、NTFS的版本和一个标明该磁盘是否损坏的标志位，NTFS文件系统以此决定是否需要调用Chkdsk程序来进行修复。</p><p>第5个记录是属性定义表（$AttrDef，attribute definition table）的记录，其中存放着卷所支持的所有文件属性，并指出它们是否可以被索引和恢复等。</p><p>第6个记录是根目录（$ROOT）的记录，其中保存着该卷根目录下的所有文件和目录的索引。在访问一个文件后，NTFS就保留该文件的MFT引用，第二次就能够直接访问该文件。</p><p>第7个记录是位图文件（$Bitmap）的记录，NTFS卷的簇使用情况都保存在这个位图文件中，其中每一位（bit）代表卷中的一簇，标识该簇是空闲还是已分配。由于该文件可以很容易被扩大，所以，NTFS的卷可以很方便地动态扩大，而FAT格式的文件系统由于涉及FAT表的变化，所以不能随意对分区大小进行调整。</p><p>第8个记录是引导文件（$Boot）的记录，该文件中存放着操作系统的引导程序代码。该文件必须位于特定的磁盘位置才能够正确地引导系统，一般都是位于卷的最前面。</p><p>第9个记录是坏簇文件（$BadClus）的记录，它记录着该卷中所有损坏的簇号，防止系统对其进行分配使用。</p><p>第10个记录是安全文件（$Secure）的记录，它存储着整个卷的安全描述符数据库。NTFS文件和目录都有各自的安全描述符，为节省空间，NTFS将文件和目录的相同描述符存放在此公共文件中。</p><p>第11个记录为大写文件（$UpCase，upper case file）的记录，该文件包含一个大小写字符转换表。</p><p>第12个记录是扩展元数据目录（$Extended metadata directory）的记录。</p><p>第13个记录是重解析点文件（$Extend&#x2F;$Reparse）的记录。</p><p>第14个记录是变更日志文件（$Extend&#x2F;$UsnJrnl）的记录。</p><p>第15个记录是配额管理文件（$Extend&#x2F;$Quota）的记录。</p><p>第16个记录是对象ID文件（$Extend&#x2F;$ObjId）的记录。</p><p>第17～23记录是系统保留的记录，暂时不用，用于将来扩展。</p><p>从第24个记录开始存放用户文件的记录。</p><h2 id="文件记录分析"><a href="#文件记录分析" class="headerlink" title="文件记录分析"></a>文件记录分析</h2><h3 id="文件记录的结构"><a href="#文件记录的结构" class="headerlink" title="文件记录的结构"></a>文件记录的结构</h3><p>MFT以文件记录来实现对文件的管路，每个文件记录都对应着不同的文件，大小固定为1KB，也就是占用两个扇区。存放文件记录位置的第一个记录就称作“基本文件记录”。文件记录在MFT中物理上是连续的，从0开始依次按顺序编号。</p><p>文件记录由两部分构成，一部分是文件记录头，另一部分是属性列表。</p><center><b>文件记录的结构</b></center><table><thead><tr><th align="center">结构</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">文件记录头</td><td align="center"></td></tr><tr><td align="center">属性1</td><td align="center"></td></tr><tr><td align="center">属性2</td><td align="center"></td></tr><tr><td align="center">……</td><td align="center"></td></tr><tr><td align="center">结束标志</td><td align="center">“FFFFFFFFH”</td></tr></tbody></table><h3 id="文件记录头的结构"><a href="#文件记录头的结构" class="headerlink" title="文件记录头的结构"></a>文件记录头的结构</h3><center><b>NTFS文件记录头信息</b></center><table><thead><tr><th align="center">字节偏移</th><th align="center">字段长度（字节）</th><th align="center">字段名和含义</th></tr></thead><tbody><tr><td align="center">0x00</td><td align="center">4</td><td align="center">MFT标志，一定为字符串“FILE”</td></tr><tr><td align="center">0x04</td><td align="center">2</td><td align="center">更新序列号（Update Sequence Number）的偏移</td></tr><tr><td align="center">0x06</td><td align="center">2</td><td align="center">更新序列号的大小与数组，包括第一个字节</td></tr><tr><td align="center">0x08</td><td align="center">8</td><td align="center">日志文件序列号（$LogFile Sequence Number，LSN）</td></tr><tr><td align="center">0x10</td><td align="center">2</td><td align="center">序列号（Sequence Number）</td></tr><tr><td align="center">0x12</td><td align="center">2</td><td align="center">硬连接数（Hard Link Count），即有多少目录指向该文件</td></tr><tr><td align="center">0x14</td><td align="center">2</td><td align="center">第一个属性的偏移地址</td></tr><tr><td align="center">0x16</td><td align="center">2</td><td align="center">标志（Flag），00H表示文件被删除，01H表示文件正在使用，02H表示目录被删除，03H表示目录正在使用</td></tr><tr><td align="center">0x18</td><td align="center">4</td><td align="center">文件记录的实际长度</td></tr><tr><td align="center">0x1C</td><td align="center">4</td><td align="center">文件记录的分配长度</td></tr><tr><td align="center">0x20</td><td align="center">8</td><td align="center">基本文件记录中的文件索引号</td></tr><tr><td align="center">0x28</td><td align="center">2</td><td align="center">下一属性ID，当增加新的属性时，将该值分配给新属性，然后该值增加，如果MFT记录重新使用，则将它置0，第一个实例总是0</td></tr><tr><td align="center">0x2A</td><td align="center">2</td><td align="center">边界，Windows XP中为偏移0x30处</td></tr><tr><td align="center">0x2C</td><td align="center">4</td><td align="center">文件记录参考号，Windows XP中使用，Windows 2000中无此参数</td></tr><tr><td align="center">0x30</td><td align="center">2</td><td align="center">更新序列号</td></tr><tr><td align="center">0x32</td><td align="center">4</td><td align="center">更新数组</td></tr></tbody></table><p>具体说明：</p><ul><li><p>偏移00H~03H为MFT的标志字符串，它总为”FILE”</p></li><li><p>每次记录被修改都将导致偏移08H~09H处的日志文件序列号$LogFile Sequence Number，LSN发生改变</p></li><li><p>偏移10H~11H处序列号Squence Number(SN)用于记录主文件表记录被重复使用的次数</p></li><li><p>偏移12H~13H处为硬连接数记录硬链接的数目，只出现在基本文件记录中</p></li><li><p>偏移18H~1FH为系统分配给文件记录的长度，一般为”00 04 00 00“，也就是1KB的长度</p></li><li><p>偏移20H~27H处为基本文件记录中的文件索引号，基本文件记录在此的值总为0。如果不为0,则是一个主文件表的文件索引号，指向所属的基本文件记录中的文件记录号。在基本文件记录中包含含有扩展文件记录的信息，存储在”属性列表 ATTRIBUTE_LIST“属性中。</p></li><li><p>偏移2CH~2FH处为文件记录编号，从0开始编号</p></li><li><p>偏移30H~31H处为更新序列号，这两个字节同时会出现在该文件记录第一个扇区最后两个字节处及该文件记录第二个扇区最后两个字节处</p></li><li><p>偏移32H~35H处为更新数组，作用如下</p><p>文件记录第一个扇区最后两个字节对应32H<del>33H处，文件记录第二个扇区最后两个字节对应34H</del>35H</p></li></ul><p><img src="https://s2.loli.net/2022/05/02/3NaZ86OSmBsKM2W.png" alt="image-20220502081633432"></p><p>当信息还没有写入该文件记录第一个扇区最后两个字节处及该文件记录第二个扇区最后两个字节时，更新数组处的四个字节就为0</p><p><img src="https://s2.loli.net/2022/05/02/PzoHyXp6V7cIEW8.png" alt="image-20220502081951064"></p><h3 id="文件记录中属性的结构"><a href="#文件记录中属性的结构" class="headerlink" title="文件记录中属性的结构"></a>文件记录中属性的结构</h3><h4 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h4><p>NTFS系统中所有与文件相关的数据均被认为是属性，包括文件的内容。文件记录是一个与文件相对于的文件属性数据库，它记录了文件数据的所有属性。</p><p>每个文件记录中都有多个属性，它们相对独立，有各自的类型和名称。一个属性的偏移00H~03H的四个字节，为该属性的类型标志，不同的属性其结构和含义各不相同。</p><center><b>属性类型及其含义</b></center><table><thead><tr><th align="center">属性类型（Little-Endian）</th><th align="center">属性类型名</th><th align="center">属性描述</th></tr></thead><tbody><tr><td align="center">10 00 00 00</td><td align="center">$STANDARD_INFORMATION</td><td align="center">标准信息：包括一些基本文件属性，如只读、系统、存档；时间属性，如文件的创建时间和最后修改时间；有多少目录指向该文件（即其硬连接数（hard link count））</td></tr><tr><td align="center">20 00 00 00</td><td align="center">$ATTRIBUTE_LIST</td><td align="center">属性列表：当一个文件需要多个文件记录时，用来描述文件的属性列表</td></tr><tr><td align="center">30 00 00 00</td><td align="center">$FILE_NAME</td><td align="center">文件名：用Unicode字符表示的文件名，由于MS-DOS不能识别长文件名，所以NTFS系统会自动生成一个8.3文件名</td></tr><tr><td align="center">40 00 00 00</td><td align="center">$VOLUME_VERSION</td><td align="center">在早期的NTFS v1.2中为卷版本</td></tr><tr><td align="center">40 00 00 00</td><td align="center">$OBJECT_ID</td><td align="center">对象ID：一个具有64字节的标识符，其中最低的16字节对卷来说是唯一的（链接跟踪服务为外壳快捷方式，即OLE链接源文件赋予对象ID；NTFS提供的API是直接通过这些对象的ID而不是文件名来打开文件的）</td></tr><tr><td align="center">50 00 00 00</td><td align="center">$SECURITY_DESCRIPTOR</td><td align="center">安全描述符：这是为向后兼容而保留的，主要用于保护文件以防止没有授权的访问，但Windows 2000&#x2F;XP中已将安全描述符存放在$Secure元数据中，以便于共享（早期的NTFS将其与文件目录一起存放，不便于共享）</td></tr><tr><td align="center">60 00 00 00</td><td align="center">$VOLUME_NAME</td><td align="center">卷名（卷标识）：该属性仅存在于$Volume元文件中</td></tr><tr><td align="center">70 00 00 00</td><td align="center">$VOLUME_INFORMATION</td><td align="center">卷信息：该属性仅存在于$Volume元文件中</td></tr><tr><td align="center">80 00 00 00</td><td align="center">$DATA</td><td align="center">文件数据：该属性为文件的数据内容</td></tr><tr><td align="center">90 00 00 00</td><td align="center">$INDEX_ROOT</td><td align="center">索引根</td></tr><tr><td align="center">A0 00 00 00</td><td align="center">$INDEX_ALLOCATION</td><td align="center">索引分配</td></tr><tr><td align="center">B0 00 00 00</td><td align="center">$BITMAP</td><td align="center">位图</td></tr><tr><td align="center">C0 00 00 00</td><td align="center">$SYMBOLIC_LINK</td><td align="center">在早期的NTFS v1.2中为符号链接</td></tr><tr><td align="center">C0 00 00 00</td><td align="center">$REPARSE_POINT</td><td align="center">重解析点</td></tr><tr><td align="center">D0 00 00 00</td><td align="center">$EA_INFORMATION</td><td align="center">扩充属性信息</td></tr><tr><td align="center">E0 00 00 00</td><td align="center">$EA</td><td align="center">扩充属性</td></tr><tr><td align="center">F0 00 00 00</td><td align="center">$PROPERTY_SET</td><td align="center">早期的NTFS v1.2中才有</td></tr><tr><td align="center">00 10 00 00</td><td align="center">$LOGGED_UTILITY_STREAM</td><td align="center">EFS加密属性：该属性主要用于存储实现EFS加密的有关加密信息，如合法用户列表、解码密钥等</td></tr></tbody></table><p>每一个属性都可以分为两个部分：属性头和属性体。</p><p><img src="https://s2.loli.net/2022/05/02/WjGfFI3qTPlkmDs.png" alt="image-20220502082918303"></p><p>如果一个属性的属性体太大而不能存放在只有1KB大小的MFT文件记录中，那么，系统将从MFT之外为之分配区域。这些区域通常称为Data Run（数据流），它们可用来存储属性体。如果属性体是不连续的，NTFS将会分配多个Data Run，以便用来管理不连续的数据。这种属性体存储在Data Run中而不是在MFT文件记录中的属性称为非常驻属性（Nonresident Attribute）。</p><h4 id="属性的属性头"><a href="#属性的属性头" class="headerlink" title="属性的属性头"></a>属性的属性头</h4><p>每个属性都有一个属性头，这个属性头包含了一些该属性的重要信息，如属性类型、属性大小、名字及是否为常驻属性等。</p><p>一个属性根据其是否常驻和是否有属性名，可以排列组合成四种不同的情况</p><ol><li>常驻没有属性名</li><li>常驻有属性名</li><li>非常驻没有属性名</li><li>非常驻有属性名</li></ol><h5 id="1-常驻没有属性名的属性头结构"><a href="#1-常驻没有属性名的属性头结构" class="headerlink" title="1.常驻没有属性名的属性头结构"></a>1.常驻没有属性名的属性头结构</h5><center><b>常驻没有属性名的属性头结构</b></center><table><thead><tr><th align="center">字节偏移</th><th align="center">字段长度（字节）</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">0x00</td><td align="center">4</td><td align="center">属性类型（如10H、30H等类型）</td></tr><tr><td align="center">0x04</td><td align="center">4</td><td align="center">包括属性头在内的本属性的长度（字节）</td></tr><tr><td align="center">0x08</td><td align="center">1</td><td align="center">是否为常驻属性（00表示常驻，01H表示非常驻）</td></tr><tr><td align="center">0x09</td><td align="center">1</td><td align="center">属性名长度（为0表示没有属性名）</td></tr><tr><td align="center">0x0A</td><td align="center">2</td><td align="center">属性名的开始偏移（没有属性名）</td></tr><tr><td align="center">0x0C</td><td align="center">2</td><td align="center">压缩、加密、稀疏标志：为0001H表示该属性是被压缩了的；为4000H表示该属性是被加密了的；为8000H表示该属性是稀疏的［NTFS下压缩文件的第二种压缩类型被称为Sparse File（稀疏文件）］</td></tr><tr><td align="center">0x0E</td><td align="center">2</td><td align="center">属性ID</td></tr><tr><td align="center">0x10</td><td align="center">4</td><td align="center">属性体的长度（L）</td></tr><tr><td align="center">0x14</td><td align="center">2</td><td align="center">属性体的开始偏移</td></tr><tr><td align="center">0x16</td><td align="center">1</td><td align="center">索引标志</td></tr><tr><td align="center">0x17</td><td align="center">1</td><td align="center">无意义</td></tr><tr><td align="center">0x18</td><td align="center">L</td><td align="center">该属性体的内容</td></tr></tbody></table><p>以下图为例子进行讲解</p><p><img src="https://s2.loli.net/2022/05/02/TLafDUrd8bE74SY.png" alt="image-20220502084058407"></p><p>偏移00H～03H的4个字节为十六进制值“10 00 00 00”，表示此属性是10H类型的属性，即$STANDARD_INFORMATION属性，称为标准信息属性；</p><p>偏移04H～07H的4个字节为包括属性头在内的属性长度，这里为十六进制值“60 00 00 00”，也就是说该属性总长度为60H；</p><p>偏移08H为非常驻属性标志，“00”表示为常驻属性，10H类型的总是常驻的，所以该字节总为00H；</p><p>偏移09H为属性名的长度，此处为十六进制数“00”，表示该属性没有属性名；</p><p>偏移0AH～0BH的两个字节为该属性名开始的偏移，此处为十六进制数“18 00”，对于没有属性名的属性，该值无意义；</p><p>偏移0CH～0DH的两个字节为属性标志，表示此属性是否是压缩、加密等，为“0000H”表示不是压缩、加密属性，只有非常驻的80H属性（数据属性）此处才可能非0000H；</p><p>偏移0EH～0FH为属性ID，此处为十六进制数“00 00”；</p><p>偏移10H～13H为属性体长度，此处为十六进制数“48 00 00 00”，也就是说属性体长度为48H；</p><p>偏移14H～15H为该属性体开始的偏移，此处为十六进制数“18 00”，表示属性体开始的偏移为18H，这也是属性头的长度；</p><p>偏移16H为索引标志，此处为“00”；</p><p>偏移17H并没有实际意义，此处为“00”；</p><p>偏移18H～98H的48H个字节是属性体的内容，其具体含义将在后文中分析。</p><h5 id="2-常驻有属性名的属性头结构"><a href="#2-常驻有属性名的属性头结构" class="headerlink" title="2.常驻有属性名的属性头结构"></a>2.常驻有属性名的属性头结构</h5><center><b>常驻有属性名的属性头结构</b></center><table><thead><tr><th align="center">字节偏移</th><th align="center">字段长度（字节）</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">0x00</td><td align="center">4</td><td align="center">属性类型（如90H、B0H等类型）</td></tr><tr><td align="center">0x04</td><td align="center">4</td><td align="center">包括属性头在内的本属性的长度（字节）</td></tr><tr><td align="center">0x08</td><td align="center">1</td><td align="center">是否为常驻属性（00表示常驻，01H表示非常驻）</td></tr><tr><td align="center">0x09</td><td align="center">1</td><td align="center">属性名长度（N）</td></tr><tr><td align="center">0x0A</td><td align="center">2</td><td align="center">属性名开始的偏移</td></tr><tr><td align="center">0x0C</td><td align="center">2</td><td align="center">压缩、加密、稀疏标志</td></tr><tr><td align="center">0x0E</td><td align="center">2</td><td align="center">属性ID</td></tr><tr><td align="center">0x10</td><td align="center">4</td><td align="center">属性体的长度（L）</td></tr><tr><td align="center">0x14</td><td align="center">2</td><td align="center">属性体的开始偏移</td></tr><tr><td align="center">0x16</td><td align="center">1</td><td align="center">索引标志</td></tr><tr><td align="center">0x17</td><td align="center">1</td><td align="center">无意义</td></tr><tr><td align="center">0x18</td><td align="center">2N</td><td align="center">属性的名字</td></tr><tr><td align="center">2N＋0x18</td><td align="center">L</td><td align="center">属性体的内容</td></tr></tbody></table><h5 id="3-非常驻没有属性名的属性头结构"><a href="#3-非常驻没有属性名的属性头结构" class="headerlink" title="3.非常驻没有属性名的属性头结构"></a>3.非常驻没有属性名的属性头结构</h5><table><thead><tr><th>字节偏移</th><th>字段长度（字节）</th><th>含义</th></tr></thead><tbody><tr><td>0x00</td><td>4</td><td>属性类型（如20H、80H等类型）</td></tr><tr><td>0x04</td><td>4</td><td>包括属性头在内的本属性的长度（字节）</td></tr><tr><td>0x08</td><td>1</td><td>是否为常驻属性（为01表示该属性为非常驻属性）</td></tr><tr><td>0x09</td><td>1</td><td>属性名长度（为0表示没有属性名）</td></tr><tr><td>0x0A</td><td>2</td><td>属性名开始的偏移（没有属性名）</td></tr><tr><td>0x0C</td><td>2</td><td>压缩、加密、稀疏标志</td></tr><tr><td>0x0E</td><td>2</td><td>属性ID</td></tr><tr><td>0x10</td><td>8</td><td>属性体的起始虚拟簇号（VCN）</td></tr><tr><td>0x18</td><td>8</td><td>属性体的结束虚拟簇号</td></tr><tr><td>0x20</td><td>2</td><td>Run List（Run即Data Run，是一个在逻辑簇号上连续的区域，它是不存储在MFT中的数据）信息的偏移地址</td></tr><tr><td>0x22</td><td>2</td><td>压缩单位大小（2x簇，如果为0表示未压缩）</td></tr><tr><td>0x24</td><td>4</td><td>无意义</td></tr><tr><td>0x28</td><td>8</td><td>属性体的分配大小［该属性体占的大小，这个属性体大小是该属性体所有的簇所占的空间大小（字节）］</td></tr><tr><td>0x30</td><td>8</td><td>属性体的实际大小（因为属性体长度不一定正好占满所有簇）</td></tr><tr><td>0x38</td><td>8</td><td>属性体的初始大小</td></tr><tr><td>0x40</td><td></td><td>属性的Run List信息，它记录了属性体开始的簇号、簇数等信息</td></tr></tbody></table><h5 id="4-非常驻有属性名的属性头结构"><a href="#4-非常驻有属性名的属性头结构" class="headerlink" title="4.非常驻有属性名的属性头结构"></a>4.非常驻有属性名的属性头结构</h5><table><thead><tr><th>字节偏移</th><th>字段长度（字节）</th><th>含义</th></tr></thead><tbody><tr><td>0x00</td><td>4</td><td>属性类型（如80H、A0H等类型）</td></tr><tr><td>0x04</td><td>4</td><td>包括属性头在内的本属性的长度（字节）</td></tr><tr><td>0x08</td><td>1</td><td>是否为常驻属性（为01表示该属性为非常驻属性）</td></tr><tr><td>0x09</td><td>1</td><td>属性名长度（N）</td></tr><tr><td>0x0A</td><td>2</td><td>属性名开始的偏移</td></tr><tr><td>0x0C</td><td>2</td><td>压缩、加密、稀疏标志</td></tr><tr><td>0x0E</td><td>2</td><td>属性ID</td></tr><tr><td>0x10</td><td>8</td><td>属性体的起始虚拟簇号（VCN）</td></tr><tr><td>0x18</td><td>8</td><td>属性体的结束虚拟簇号</td></tr><tr><td>0x20</td><td>2</td><td>Run List（Run即Data Run，是一个在逻辑簇号上连续的区域，它是不存储在MFT中的数据）信息的偏移地址</td></tr><tr><td>0x22</td><td>2</td><td>压缩单位大小（2x簇，如果为0表示未压缩）</td></tr><tr><td>0x24</td><td>4</td><td>无意义</td></tr><tr><td>0x28</td><td>8</td><td>属性体的分配大小［该属性体占的大小，这个属性体大小是该属性体所有的簇所占的空间大小（字节）］</td></tr><tr><td>0x30</td><td>8</td><td>属性体的实际大小（因为属性体长度不一定正好占满所有簇）</td></tr><tr><td>0x38</td><td>8</td><td>属性体的初始大小</td></tr><tr><td>0x40</td><td>2N</td><td>该属性的属性名</td></tr><tr><td>2N＋0x40</td><td></td><td>属性的Run List信息，它记录了属性体开始的簇号、簇数等信息</td></tr></tbody></table><h2 id="10H（-STANDARD-INFORMATION）属性分析"><a href="#10H（-STANDARD-INFORMATION）属性分析" class="headerlink" title="10H（$STANDARD_INFORMATION）属性分析"></a>10H（$STANDARD_INFORMATION）属性分析</h2><p><a href="https://www.dgxue.com/huifu/tag/10h/">10H</a>类型属性即$STANDARD_INFORMATION属性，它包含文件的一些基本信息，如文件的传统属性、文件的创建时间和最后修改时间、有多少目录指向该文件（即其硬连接数）等。</p><center><b>10H属性体的含义</b></center><table><thead><tr><th>字节偏移</th><th>字段长度（字节）</th><th>含义</th></tr></thead><tbody><tr><td>～</td><td>～</td><td>属性头（已分析过）</td></tr><tr><td>0x00</td><td>8</td><td>文件创建时间</td></tr><tr><td>0x08</td><td>8</td><td>文件最后修改时间</td></tr><tr><td>0x10</td><td>8</td><td>MFT修改时间</td></tr><tr><td>0x18</td><td>8</td><td>文件最后访问时间</td></tr><tr><td>0x20</td><td>4</td><td>传统文件属性</td></tr><tr><td>0x24</td><td>4</td><td>最大版本数：为0则表示版本是没有的</td></tr><tr><td>0x28</td><td>4</td><td>版本数：如果偏移24H处为0则此处也为0</td></tr><tr><td>0x2C</td><td>4</td><td>分类ID（一个双向的类索引）</td></tr><tr><td>0x30</td><td>4</td><td>所有者ID：表示文件的所有者，是访问文件配额$Quota中$O和$Q索引的关键字，如果为0则表示没有设置配额</td></tr><tr><td>0x34</td><td>4</td><td>安全ID：是文件$Secure中$SII索引和$SDS数据流的关键字，注意不要与安全标识相混淆</td></tr><tr><td>0x38</td><td>8</td><td>配额管理：配额占用情况，它是文件所有流所占用的总字节数，为0表示末使用磁盘配额</td></tr><tr><td>0x40</td><td>8</td><td>更新序列号（USN）：文件最后的根新序列号，它是进入元数据文件$UsnJrnl直接的索引，如果为0，则表示没有USN日志</td></tr></tbody></table><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol><li><p>64为时间区域说明</p><p><a href="https://www.dgxue.com/huifu/tag/ntfs/">NTFS</a>文件时间用长达64位来表示文件的某种时间（含日期），而在FAT文件系统中只用了32位来表示文件的时间和日期，NTFS文件系统中的文件时间的64位的数据表示的是有多少个100个10亿分之一秒（100-nanosecond也就是千万分之一秒）。</p></li><li><p>传统文件属性</p></li></ol><center><b>传统属性表</b></center><table><thead><tr><th align="center">标志</th><th align="center">二进制位</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">0x0001</td><td align="center">0000 0000　0000 0001</td><td align="center">只读</td></tr><tr><td align="center">0x0002</td><td align="center">0000 0000　0000 0010</td><td align="center">隐含</td></tr><tr><td align="center">0x0004</td><td align="center">0000 0000　0000 0100</td><td align="center">系统</td></tr><tr><td align="center">0x0020</td><td align="center">0000 0000　0010 0000</td><td align="center">存档</td></tr><tr><td align="center">0x0040</td><td align="center">0000 0000　0100 0000</td><td align="center">设备</td></tr><tr><td align="center">0x0080</td><td align="center">0000 0000　1000 0000</td><td align="center">常规</td></tr><tr><td align="center">0x0100</td><td align="center">0000 0001　0000 0000</td><td align="center">临时</td></tr><tr><td align="center">0x0200</td><td align="center">0000 0010　0000 0000</td><td align="center">稀疏文件</td></tr><tr><td align="center">0x0400</td><td align="center">0000 0100　0000 0000</td><td align="center">重解析点</td></tr><tr><td align="center">0x0800</td><td align="center">0000 1000　0000 0000</td><td align="center">压缩</td></tr><tr><td align="center">0x1000</td><td align="center">0001 0000　0000 0000</td><td align="center">脱机</td></tr><tr><td align="center">0x2000</td><td align="center">0010 0000　0000 0000</td><td align="center">未编入索引</td></tr><tr><td align="center">0x4000</td><td align="center">0100 0000　0000 0000</td><td align="center">加密</td></tr></tbody></table><h2 id="20H（-ATTRIBUTE-LIST）属性分析"><a href="#20H（-ATTRIBUTE-LIST）属性分析" class="headerlink" title="20H（$ATTRIBUTE_LIST）属性分析"></a>20H（$ATTRIBUTE_LIST）属性分析</h2><p><a href="https://www.dgxue.com/huifu/tag/20h/">20H</a>类型属性是$ATTRIBUTE_LIST属性，即属性列表，当一个文件需要多个文件记录时，用来描述文件的属性列表。</p><p>如果文件记录里的某个属性大到该文件记录不能把该属性完全存储时，系统会采取用Run List来存储这些属性的属性体，这种属性被称为非常驻属性。但是如果这样仍然没有足够的空间时，那么就需要属性列表了。不能完全放进该文件记录中的属性会被放置在一个新的文件记录中，而属性列表属性描述了应该如何找到这个新的文件记录。</p><center><b>20H属性描述表</b></center><table><thead><tr><th align="center">字节偏移</th><th align="center">字段长度（字节）</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">～</td><td align="center">～</td><td align="center">标准属性头（已分析过）</td></tr><tr><td align="center">0x00</td><td align="center">4</td><td align="center">类型</td></tr><tr><td align="center">0x04</td><td align="center">2</td><td align="center">记录长度</td></tr><tr><td align="center">0x06</td><td align="center">1</td><td align="center">属性名长度（N，为0表示没有属性名）</td></tr><tr><td align="center">0x07</td><td align="center">1</td><td align="center">属性名偏移（如果没有属性名，则指向属性内容）</td></tr><tr><td align="center">0x08</td><td align="center">8</td><td align="center">起始VCN（属性常驻时为0）</td></tr><tr><td align="center">0x10</td><td align="center">8</td><td align="center">属性的基本文件记录中的文件参考号（所有MFT的文件都有一个文件索引号，引用到这个文件参考号，等价于引用这个文件记录，这个参考号在文件记录头中有定义）</td></tr><tr><td align="center">0x18</td><td align="center">2</td><td align="center">属性ID（每个属性都有一个唯一的ID号）</td></tr><tr><td align="center">0x1A</td><td align="center">2N</td><td align="center">Unicode属性名（如果有属性名）</td></tr></tbody></table><p>20H类型的属性很少见，但有四种情况让系统可能需要20H类型的属性，这四种情况是：</p><p>①文件有很多的硬连接（即有很多的文件名属性存在）；</p><p>②文件有很多碎片，以至文件记录中记录不了这么多的Data Run（数据流）；</p><p>③属性中有很复杂的安全描述（不适用于NTFS v4.0以上版本）；</p><p>④属性中有很多的命名流，如数据流。</p><p>20H属性可以是常驻的，也可以是非常驻的.</p><center>常驻的20H属性</center><p><img src="https://s2.loli.net/2022/05/02/N8IolqMjacRW5gT.png" alt="image-20220502090939456"></p><center>非常驻的20H属性</center><p><img src="https://s2.loli.net/2022/05/02/4RC8xo91FTKGmVW.png" alt="image-20220502091102191"></p><h2 id="30H（-FILE-NAME）属性分析"><a href="#30H（-FILE-NAME）属性分析" class="headerlink" title="30H（$FILE_NAME）属性分析"></a>30H（$FILE_NAME）属性分析</h2><p>30H类型属性，即$FILE_NAME属性，该属性用于存储文件名，它总是常驻属性。它最少68字节，最大578字节，可容纳最大255个Unicode字符的文件名长度。</p><center>30H属性描述表</center><table><thead><tr><th align="center">字节偏移</th><th align="center">字段长度（字节）</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">～</td><td align="center">～</td><td align="center">标准属性头（已分析过）</td></tr><tr><td align="center">0x00</td><td align="center">8</td><td align="center">父目录的文件参考号（即父目录的基本文件记录号，分为两个部分，前6个字节48位为父目录的文件记录号，后2个字节为序列号）</td></tr><tr><td align="center">0x08</td><td align="center">8</td><td align="center">文件创建时间</td></tr><tr><td align="center">0x10</td><td align="center">8</td><td align="center">文件修改时间</td></tr><tr><td align="center">0x18</td><td align="center">8</td><td align="center">MFT修改时间</td></tr><tr><td align="center">0x20</td><td align="center">8</td><td align="center">文件最后访问时间</td></tr><tr><td align="center">0x28</td><td align="center">8</td><td align="center">文件分配大小</td></tr><tr><td align="center">0x30</td><td align="center">8</td><td align="center">文件实际大小</td></tr><tr><td align="center">0x38</td><td align="center">4</td><td align="center">标志，如目录、压缩、隐藏等</td></tr><tr><td align="center">0x3C</td><td align="center">4</td><td align="center">EAs（扩展属性）和Reparse（重解析点）使用</td></tr><tr><td align="center">0x40</td><td align="center">1</td><td align="center">文件名长度（字符数L）</td></tr><tr><td align="center">0x41</td><td align="center">1</td><td align="center">文件名命名空间（Filename Namespace）</td></tr><tr><td align="center">0x42</td><td align="center">2L</td><td align="center">Unicode文件名</td></tr></tbody></table><p>NTFS通过为一个文件创建多个文件名属性的方式实现了POSIX（可移植操作系统接口）式的硬连接，每个文件名属性都有它自己的详细资料和父目录参考号。当一个硬连接文件删除时，就从文件记录中删除掉这个文件名，当最后一个连接也删除时，文件就真正的删除了。</p><p>如果文件有EAs（扩展属性），则EA域将包含有缓存所需要的空间。</p><p>如果文件是个重解析点，则会在重解析点域给出它的类型，这在后文谈重解析点属性时有详细说明。</p><h3 id="30H属性的文件标志含义"><a href="#30H属性的文件标志含义" class="headerlink" title="30H属性的文件标志含义"></a>30H属性的文件标志含义</h3><center><b>30H属性文件标志字节含义</b><center><table><thead><tr><th align="center">标志</th><th align="center">二进制位</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">0x0001</td><td align="center">0000 0000　0000 0001</td><td align="center">只读</td></tr><tr><td align="center">0x0002</td><td align="center">0000 0000　0000 0010</td><td align="center">隐含</td></tr><tr><td align="center">0x0004</td><td align="center">0000 0000　0000 0100</td><td align="center">系统</td></tr><tr><td align="center">0x0020</td><td align="center">0000 0000　0010 0000</td><td align="center">存档</td></tr><tr><td align="center">0x0040</td><td align="center">0000 0000　0100 0000</td><td align="center">设备</td></tr><tr><td align="center">0x0080</td><td align="center">0000 0000　1000 0000</td><td align="center">常规</td></tr><tr><td align="center">0x0100</td><td align="center">0000 0001　0000 0000</td><td align="center">临时</td></tr><tr><td align="center">0x0200</td><td align="center">0000 0010　0000 0000</td><td align="center">稀疏文件</td></tr><tr><td align="center">0x0400</td><td align="center">0000 0100　0000 0000</td><td align="center">重解析点</td></tr><tr><td align="center">0x0800</td><td align="center">0000 1000　0000 0000</td><td align="center">压缩</td></tr><tr><td align="center">0x1000</td><td align="center">0001 0000　0000 0000</td><td align="center">脱机</td></tr><tr><td align="center">0x2000</td><td align="center">0010 0000　0000 0000</td><td align="center">未编入索引</td></tr><tr><td align="center">0x4000</td><td align="center">0100 0000　0000 0000</td><td align="center">加密</td></tr><tr><td align="center">0x10000000</td><td align="center">0001 0000　0000 0000 （前2个字节）</td><td align="center">目录（从MFT文件记录中复制的相应的位）</td></tr><tr><td align="center">0x20000000</td><td align="center">0010 0000　0000 0000 （前2个字节）</td><td align="center">索引视图（从MFT文件记录中复制的相应的位）</td></tr></tbody></table><h3 id="30H属性的文件命名空间"><a href="#30H属性的文件命名空间" class="headerlink" title="30H属性的文件命名空间"></a>30H属性的文件命名空间</h3><p>可能的文件命名空间有</p><p>（1）该字节的值为“00”：POSIX（Portable Operating System Interface，可移植操作系统接口）</p><p>Windows 20000、Windows XP完全支持可移植操作系统接口POSIX 1003.1。在文件系统方面，NTFS实现了POSIX 1003.1的所有要求，例如：</p><p>①大小写敏感：在POSIX环境下，文件名是大小写敏感的，因而在POSIX命名空间ABC.TXT、Abc.txt、abc.txt并不是同一个文件。</p><p>②通过许可：当判定一个用户是否可以访问一个文件或者目录时，需要考虑路径上的所有目录的安全许可。</p><p>③文件改变时间：提供文件最后被访问的时间标记（这在10属性中定义）。</p><p>④硬连接：在不同的目录下不同文件名的两个文件指向相同的数据时，两个文件发生硬连接。</p><p>POSIX是最大的文件命名空间，它允许除了空字符（00H）和向前的斜线“&#x2F;”以外所有的Unicode字符集，最大的文件名长度为255，但是有一些特例，例如冒号“：”，在NTFS文件系统中是有效，但在Windows操作系统是不允许的。</p><p>（2）该字节的值为“01”：Win32</p><p>Win32是POSIX命名空间的一个子集，它使用除“”*&#x2F;：＜＞?|”之外的所有Unicode字符集，但注意名字不能够以“.”或空格结束。</p><p>（3）该字节的值为“02”：DOS</p><p>DOS是Win32命名空间的一个子集，只允许用大写字符，不能用空格，而且排除“”*＋，&#x2F;：；＜＝＞?\”等字符做文件名。注意其文件名一定是这样的：1～8个字符的文件名，然后是一个点“.”，然后是0～3个字符的扩展名。</p><p>（4）该字节的值为“03”：Win32 ＆ DOS</p><p>这种文件命名空间表示Win32和DOS文件名都是一样的（也就是说该文件只有一个符合DOS命名方式的文件名），因此这种文件名只有这一个文件名属性。</p><p>将POSIX或Win32文件名转换成DOS兼容文件名必须遵从以下步骤：</p><p>①除去所有的Unicode字符；</p><p>②除去除最后一个外的所有的“.”，且这最后一个“.”还不能是首字符；</p><p>③将所有的小写字符转换为大写；</p><p>④除去被禁止的字符；</p><p>⑤如果此时主文件名长度（即“.”之前的长度）大于8个字符，则除去第6个字符后的所有字符，其在其后补上两个字符“～1”；</p><p>⑥在“.”之后如果字符长度大于3，则只保留前3个字符；</p><p>⑦当这个文件名已经存在时，则把“～1”变成“～2”，如果依然存在则继续递增字符“～”后的数字。</p><h2 id="40H（-OBJECT-ID）属性分析"><a href="#40H（-OBJECT-ID）属性分析" class="headerlink" title="40H（$OBJECT_ID）属性分析"></a>40H（$OBJECT_ID）属性分析</h2><p><a href="https://www.dgxue.com/huifu/tag/40h/">40H</a>类型属性即$OBJECT_ID属性，也就是对象ID，它是从Windows 2000开始引入的属性。每一个MFT记录都被指定一个唯一的GUID（全局ID，Windows为所有对象分配的一个全局唯一的数字标识，16字节长）。此外，记录还可能包含有一个所属卷ID、原始对象ID和域ID，这些都属于GUID，在NTFS文件系统中所提供的API就是通过这些ID对文件进行访问的，该属性最大不超过256字节。</p><center><b>40H属性描述表</b></center><table><thead><tr><th align="center">字节偏移</th><th align="center">字段长度（字节）</th><th align="center">名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">～</td><td align="center">～</td><td align="center">标准属性头</td><td align="center">（已经分析过）</td></tr><tr><td align="center">0x00</td><td align="center">16</td><td align="center">全局对象ID（GUID Object ID）</td><td align="center">指派给文件的一个唯一的ID号</td></tr><tr><td align="center">0x10</td><td align="center">16</td><td align="center">全局原始卷ID（GUID Birth Volume ID）</td><td align="center">创建文件的卷的ID（永不变化）</td></tr><tr><td align="center">0x20</td><td align="center">16</td><td align="center">全局原始对象ID（GUID Birth Object ID）</td><td align="center">原始对象ID（它是曾经指派给本文件记录的第一个对象ID，如果由于某种原因导致对象ID发生变化，此值就可以反映出对象ID的原始值）</td></tr><tr><td align="center">0x30</td><td align="center">16</td><td align="center">全局域ID（GUID Domain ID）</td><td align="center">创建对象的域ID</td></tr></tbody></table><p>40H类型的属性绝大多数只有16字节，也就是只有一个全局ID，即对象ID，如果原始卷ID、原始对象ID和域ID没有被使用，它也有可能在属性中占用了空间，但是其值可能是零。</p><h2 id="50H（-SECURITY-DESCRIPTOR）属性分析"><a href="#50H（-SECURITY-DESCRIPTOR）属性分析" class="headerlink" title="50H（$SECURITY_DESCRIPTOR）属性分析"></a>50H（$SECURITY_DESCRIPTOR）属性分析</h2><p>50H类型属性即$SECURITY_DESCRIPTOR属性，也就是安全描述符，主要用于保护文件以防止没有授权的访问，但Windows 2000&#x2F;XP中已将安全描述符存放在$Secure元数据中，以便于共享（早期的NTFS将其与文件目录一起存放，不便于共享）。</p><center><b>50H属性描述表</b></center><p><img src="https://s2.loli.net/2022/05/02/jTpaJnAvgKbF3dV.jpg" alt="50H（$SECURITY_DESCRIPTOR）属性分析-数据恢复迷"></p><p>在一个标准属性头后是一个50H特有的属性头，其后跟一个或两个ACL（Access Control List，访问控制列表）和两个SID（Security Identifier，安全ID）。</p><p>ACL即访问控制列表，它赋予或拒绝特定用户或组访问某个对象的权限的对象安全描述符的组成部分。只有某个对象的所有者才可以更改ACL中赋予或拒绝的权限，这样，此对象的所有者就可以自由访问该对象。</p><p>SID即安全标识符，它是用来识别用户、组和计算机账户的不同长度的数据结构。在第一次创建该账户时，将给网络上的每一个账户发布一个唯一的SID。Windows中的内部进程将引用账户的SID而不是账户的用户名或组名。</p><p>第一个ACL（Access Control Entry）包括审核信息，即访问对象时要审核的组和用户账户，但也可能没有；第二个ACL包括权限，即授予的每个组或用户的权限的每个访问事件的成功或失败属性。</p><p>每一个ACL可能包括一个或多个ACE，ACE即访问控制项，它是授予用户或组权限的ACL中的一个项目。ACE也是对象的系统访问控制列表（SACL）中的项目，该列表指定用户或组要审核的安全事件，每一个ACE包括一个SID。</p><p>SACL是表示部分对象的安全描述符的列表，该安全描述符指定了每个用户或组的哪个事件将被审核。审核事件的例子是文件访问、登录尝试和系统关闭。</p><p>最后两个SID表示对象的所有者即用户和组。</p><h3 id="50H属性中属性头的结构"><a href="#50H属性中属性头的结构" class="headerlink" title="50H属性中属性头的结构"></a>50H属性中属性头的结构</h3><table><thead><tr><th align="center">字节偏移</th><th align="center">字段长度（字节）</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">0x00</td><td align="center">1</td><td align="center">头1（通常总是01）</td></tr><tr><td align="center">0x01</td><td align="center">1</td><td align="center">头2（通常总是00）</td></tr><tr><td align="center">0x02</td><td align="center">1</td><td align="center">头3（通常为0x04或0x14，前者表示无审计，后者表示有审计）</td></tr><tr><td align="center">0x03</td><td align="center">1</td><td align="center">头4（通常总是80H）</td></tr><tr><td align="center">0x04</td><td align="center">4</td><td align="center">用户SID的偏移</td></tr><tr><td align="center">0x08</td><td align="center">4</td><td align="center">组SID的偏移</td></tr><tr><td align="center">0x0C</td><td align="center">4</td><td align="center">ACL审核</td></tr><tr><td align="center">0x10</td><td align="center">4</td><td align="center">ACL权限</td></tr></tbody></table><h3 id="50H属性中ACL的结构"><a href="#50H属性中ACL的结构" class="headerlink" title="50H属性中ACL的结构"></a>50H属性中ACL的结构</h3><table><thead><tr><th align="center">字节偏移</th><th align="center">字段长度（字节）</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">0x00</td><td align="center">1</td><td align="center">ACL版本</td></tr><tr><td align="center">0x01</td><td align="center">1</td><td align="center">常为“00”，无意义</td></tr><tr><td align="center">0x02</td><td align="center">2</td><td align="center">ACL长度</td></tr><tr><td align="center">0x04</td><td align="center">2</td><td align="center">ACE合计</td></tr><tr><td align="center">0x06</td><td align="center">2</td><td align="center">常为“00 00”，无意义</td></tr></tbody></table><h3 id="50H属性中ACE的结构"><a href="#50H属性中ACE的结构" class="headerlink" title="50H属性中ACE的结构"></a>50H属性中ACE的结构</h3><center><b>ACE描述表</b></center><table><thead><tr><th align="center">字节偏移</th><th align="center">字段长度（字节）</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">0x00</td><td align="center">1</td><td align="center">类型</td></tr><tr><td align="center">0x01</td><td align="center">1</td><td align="center">标志</td></tr><tr><td align="center">0x02</td><td align="center">2</td><td align="center">大小</td></tr><tr><td align="center">0x04</td><td align="center">4</td><td align="center">访问掩码</td></tr><tr><td align="center">0x08</td><td align="center">V</td><td align="center">SID</td></tr></tbody></table><center><b>ACE的标志</b></center><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">0x00</td><td align="center">访问允许</td></tr><tr><td align="center">0x01</td><td align="center">访问拒绝</td></tr><tr><td align="center">0x02</td><td align="center">系统审核</td></tr></tbody></table><center><b>目录的ACE标志描述</b></center><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">0x01</td><td align="center">对象继承的ACE</td></tr><tr><td align="center">0x02</td><td align="center">容器继承的ACE</td></tr><tr><td align="center">0x04</td><td align="center">不传播继承的ACE’</td></tr><tr><td align="center">0x08</td><td align="center">只继承ACE</td></tr></tbody></table><center><b>系统审核的ACL标志描述</b></center><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">0x40</td><td align="center">审核成功</td></tr><tr><td align="center">0x80</td><td align="center">审核失败</td></tr></tbody></table><center><b>ACL访问掩码</b><table><thead><tr><th align="center">位偏移</th><th align="center">含义</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">0～15</td><td align="center">对象特殊访问权限</td><td align="center">读数据、执行、添加数据</td></tr><tr><td align="center">16～22</td><td align="center">标准访问权限</td><td align="center">删除、修改ACL、修改所有者</td></tr><tr><td align="center">23</td><td align="center">可以访问ACL</td><td align="center"></td></tr><tr><td align="center">24～27</td><td align="center">保留</td><td align="center"></td></tr><tr><td align="center">28</td><td align="center">所有（读、写、执行）</td><td align="center">所有事情</td></tr><tr><td align="center">29</td><td align="center">执行</td><td align="center">执行程序所需的所有权力</td></tr><tr><td align="center">30</td><td align="center">写</td><td align="center">写文件所需的所有权力</td></tr><tr><td align="center">31</td><td align="center">读</td><td align="center">读文件所需的所有权力</td></tr></tbody></table><h3 id="50H属性中SID的结构"><a href="#50H属性中SID的结构" class="headerlink" title="50H属性中SID的结构"></a>50H属性中SID的结构</h3><p>典型的SID形由’S-p-q-r-s-t-u-v’组成</p><center><b>SID结构</b></center><table><thead><tr><th align="center">S</th><th align="center">安全</th></tr></thead><tbody><tr><td align="center">p</td><td align="center">版本号（目前为1）</td></tr><tr><td align="center">q</td><td align="center">NT域，该数值占6个字节</td></tr><tr><td align="center">r～v</td><td align="center">NT子域（可能有几个这样的子域）</td></tr></tbody></table><center><b>SID在磁盘上的存储</b><p><img src="https://s2.loli.net/2022/05/02/zepGIBRcyE61sAD.jpg" alt="50H（$SECURITY_DESCRIPTOR）属性分析-数据恢复迷"></p><p>在S-1-5-21-646518322-1873620750-619646970-1110这个SID中，“S”是SID简称，“1”为版本号，“5”为标识授权，“21”为子授权，“646518322”为SA（Security Association，安全协会），“1873620750”为SA的域ID，“619646970”也是SA，“1110”为用户ID。</p><center><b>安全表示的组成部分</b></center><table><thead><tr><th align="center">标识授权</th><th align="center">缩写</th></tr></thead><tbody><tr><td align="center">无效SID</td><td align="center">S-1-0</td></tr><tr><td align="center">全球SID</td><td align="center">S-1-1</td></tr><tr><td align="center">本地SID</td><td align="center">S-1-2</td></tr><tr><td align="center">创建者SID</td><td align="center">S-1-3</td></tr><tr><td align="center">非唯一SID</td><td align="center">S-1-4</td></tr><tr><td align="center">NT SID</td><td align="center">S-1-5</td></tr></tbody></table><p>子授权中的R表示相关ID（Relative Identifiers），用以和标识授权一起组成知名SID</p><center><b>相关ID</b></center><p><img src="https://s2.loli.net/2022/05/02/JkAqCjsLguBOQGw.jpg" alt="50H（$SECURITY_DESCRIPTOR）属性分析-数据恢复迷"></p><center><b>常见知名域用户</b></center><table><thead><tr><th align="center">域用户</th><th align="center">代码</th></tr></thead><tbody><tr><td align="center">Admin（管理员）</td><td align="center">500</td></tr><tr><td align="center">Guest（来宾）</td><td align="center">501</td></tr><tr><td align="center">Kerberos Target（安全验证用）</td><td align="center">502</td></tr></tbody></table><center><b>常见知名域组</b></center><table><thead><tr><th align="center">域组</th><th align="center">代码</th></tr></thead><tbody><tr><td align="center">Admins（管理员组）</td><td align="center">512</td></tr><tr><td align="center">Users（用户组）</td><td align="center">513</td></tr><tr><td align="center">Guests（来宾组）</td><td align="center">514</td></tr><tr><td align="center">Computers（计算机组）</td><td align="center">515</td></tr><tr><td align="center">Controllers（控制员组）</td><td align="center">516</td></tr><tr><td align="center">Cert Admins（确定管理员组）</td><td align="center">517</td></tr><tr><td align="center">Schema Admins（计划管理员组）</td><td align="center">518</td></tr><tr><td align="center">Enterprise Admins（企业管理员组）</td><td align="center">519</td></tr><tr><td align="center">Policy Admins（策略管理员组）</td><td align="center">520</td></tr></tbody></table><center><b>常见知名域别名</b>    </center><table><thead><tr><th align="center">域别名</th><th align="center">代码</th></tr></thead><tbody><tr><td align="center">Admins（管理员组）</td><td align="center">544</td></tr><tr><td align="center">Users（用户组）</td><td align="center">545</td></tr><tr><td align="center">Guests（来宾组）</td><td align="center">546</td></tr><tr><td align="center">Power Users（高级用户组）</td><td align="center">547</td></tr><tr><td align="center">Account Ops（账号操作）</td><td align="center">548</td></tr><tr><td align="center">System Ops（系统操作）</td><td align="center">549</td></tr><tr><td align="center">Print Ops（打印操作）</td><td align="center">550</td></tr><tr><td align="center">Backup Ops（备份操作）</td><td align="center">551</td></tr><tr><td align="center">Replicator（复制操作）</td><td align="center">552</td></tr><tr><td align="center">RAS Servers</td><td align="center">553</td></tr><tr><td align="center">Pre W2K Comp Access</td><td align="center">554</td></tr></tbody></table><center><b>SID的控制标志</b><table><thead><tr><th align="center">标志</th><th align="center">描述</th><th align="center">标志</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">0x0001</td><td align="center">默认所有者</td><td align="center">0x0200</td><td align="center">SACL自动继承Req</td></tr><tr><td align="center">0x0002</td><td align="center">默认组</td><td align="center">0x00400</td><td align="center">DACL自动继承</td></tr><tr><td align="center">0x0004</td><td align="center">DACL存在</td><td align="center">0x0800</td><td align="center">SACL自动继承</td></tr><tr><td align="center">0x0008</td><td align="center">DACL默认值</td><td align="center">0x1000</td><td align="center">DACL保护</td></tr><tr><td align="center">0x0010</td><td align="center">SACL存在</td><td align="center">0x2000</td><td align="center">SACL保护</td></tr><tr><td align="center">0x0020</td><td align="center">SACL默认值</td><td align="center">0x4000</td><td align="center">RM控制有效</td></tr><tr><td align="center">0x0100</td><td align="center">DACL自动继承Req</td><td align="center">0x8000</td><td align="center">自相关标志</td></tr></tbody></table><p>其中默认所有者是一个布尔标志，设置时表示通过默认机制由所有者域来指示SID，而不是采用由最初的安全描述符所显式指定的SID。它将对所有者继承的处理方式产生影响。默认组的设置同默认所有者一样。</p><p>DACL存在是一个布尔标志，设置时表示安全描述包含一个自由的ACL。如果设置了该位，而安全描述的DACL域为空，则将此空ACL列入清单。</p><p>DACL（任意访问控制列表）默认值是一个布尔标志，设置时表示通过默认机制由DACL域来指示ACL，而不是由最初的安全描述指定ACL。它将对ACL继承的处理方式产生影响。如果DACL存在没有设置，则忽略该标志。</p><p>SACL存在是一个布尔标志，设置时表示安全描述包含一个由SACL域指定的系统ACL。如果设置了该位，而安全描述的SACL域为空，则将此空ACL（但确实存在）列入清单。</p><p>SACL默认值是一个布尔标志，设置时表示通过默认机制由SACL域来指示ACL，而不是由最初的安全描述指定ACL。它将对ACL继承的处理方式产生影响。如果SACL存在没有设置，则忽略该标志。</p><p>自相关标志是一个布尔标志，设置时表示安全描述是一个自相关表。在该表中，安全描述的所有域在内存中都是连续的，所有的指示域都明确的用从相对安全描述的起始处的偏移来表示。</p><p>在NTFS 4.0以上版本中，所有的安全描述都集中存储在$Secure文件中，通过标准信息属性中的安全ID属性来找到正确的安全描述。每个唯一的安全描述都指派一个唯一的安全标识（security_id，但不是SID），卷中的security_id是唯一的，作为$SII索引的一个索引来使用，并存储为$SDS的数据流属性。$SII索引按security_id的升序进行存储。</p><p>50H属性可以常驻，也可以非常驻。</p><h2 id="60H（-VOLUME-NAME）属性分析"><a href="#60H（-VOLUME-NAME）属性分析" class="headerlink" title="60H（$VOLUME_NAME）属性分析"></a>60H（$VOLUME_NAME）属性分析</h2><p><a href="https://www.dgxue.com/huifu/tag/60h/">60H</a>类型属性即$VOLUME_NAME，这个属性只是简单的包含卷的名称。它最小占两字节，最大占256字节，所以卷名最长为127个Unicode字符（必须留一个Unicode字符作为结束标志）。</p><h3 id="60H类型属性描述"><a href="#60H类型属性描述" class="headerlink" title="60H类型属性描述"></a>60H类型属性描述</h3><table><thead><tr><th align="center">字节偏移</th><th align="center">字段长度（字节）</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">～</td><td align="center">～</td><td align="center">标准属性头（已分析过）</td></tr><tr><td align="center">0x00</td><td align="center"></td><td align="center">Unicode卷名</td></tr></tbody></table><p>在60H属性中，通过Unicode字符为空来表示卷名结束，它的长度属性存储在头部中，卷序列号存储在$Boot元文件中</p><h2 id="70H（-VOLUME-INFORMATION）属性分析"><a href="#70H（-VOLUME-INFORMATION）属性分析" class="headerlink" title="70H（$VOLUME_INFORMATION）属性分析"></a>70H（$VOLUME_INFORMATION）属性分析</h2><p><a href="https://www.dgxue.com/huifu/tag/70h/">70H</a>类型属性即$VOLUME_INFORMATION，该属性说明卷的版本和状态，只有在元文件$Volum出现，其属性长为12字节（但实际上总是占用了16字节，这是因为属性的长度总是8的倍数）</p><h3 id="70H类型属性描述"><a href="#70H类型属性描述" class="headerlink" title="70H类型属性描述"></a>70H类型属性描述</h3><table><thead><tr><th>字节偏移</th><th>字段长度（字节）</th><th>含义</th></tr></thead><tbody><tr><td>～</td><td>～</td><td>标准属性头（已分析过）</td></tr><tr><td>0x00</td><td>8</td><td>总为0</td></tr><tr><td>0x08</td><td>1</td><td>主版本号</td></tr><tr><td>0x09</td><td>1</td><td>次版本号</td></tr><tr><td>0x0A</td><td>2</td><td>标志</td></tr><tr><td>0x0C</td><td>4</td><td>总为0</td></tr></tbody></table><h3 id="70H属性标志的含义"><a href="#70H属性标志的含义" class="headerlink" title="70H属性标志的含义"></a>70H属性标志的含义</h3><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>0x0001</td><td>坏区标志</td></tr><tr><td>0x0002</td><td>调整日志文件大小</td></tr><tr><td>0x0004</td><td>更新装载</td></tr><tr><td>0x0008</td><td>装载到NT4</td></tr><tr><td>0x0010</td><td>删除进行中的USN</td></tr><tr><td>0x0020</td><td>修复对象ID</td></tr><tr><td>0x8000</td><td>用chkdsk修正</td></tr></tbody></table><p>坏区标志为1时，Windows NT、Windows 2000、Windows XP就必须在下次重启时运行chkdsk&#x2F;F命令对卷进行修复。在这些系统中可以用fsutil命令对该位进行操作坏区设置和查询等操作，其语法为：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsutil dirty &#123;query|<span class="built_in">set</span>&#125; PathName</span><br></pre></td></tr></table></figure><p>参数query表示查询指定卷是否为坏区，参数set表示将卷设置为坏区，参数PathName则指定驱动器号（用冒号分隔）、装入点或卷名。如果设置了卷的坏区，则表明文件系统可能处于不一致的状态。</p><p>由于下述原因可以设置坏区：卷已联机且发生了明显的变化，或对卷作了更改，但在更改写入到磁盘前关闭了计算机，或者因为在卷上检测到损坏。如果重新启动计算机时设置了坏区，则运行chkdsk可以验证卷的一致性。每次启动系统时，内核程序将调用Autochk.exe扫描所有的卷，以查看是否设置了卷的坏区。如果设置了坏区，则autochk将立即在卷上执行chkdsk&#x2F;f。chkdsk&#x2F;f将验证文件系统的完整性并试图修复卷上的任何故障。</p><h3 id="70H属性的版本号"><a href="#70H属性的版本号" class="headerlink" title="70H属性的版本号"></a>70H属性的版本号</h3><table><thead><tr><th align="center">操作系统</th><th align="center">NTFS版本（主.次）</th></tr></thead><tbody><tr><td align="center">Windows NT</td><td align="center">1.2</td></tr><tr><td align="center">Windows 2000</td><td align="center">3.0</td></tr><tr><td align="center">Windows XP</td><td align="center">3.1</td></tr><tr><td align="center">Windows 2003</td><td align="center">3.1</td></tr><tr><td align="center">Windows Vista</td><td align="center">3.1</td></tr></tbody></table><h2 id="80H（-DATA）属性分析"><a href="#80H（-DATA）属性分析" class="headerlink" title="80H（$DATA）属性分析"></a>80H（$DATA）属性分析</h2><p><a href="https://www.dgxue.com/huifu/tag/80h/">80H</a>类型属性即$DATA属性，该属性容纳着文件的内容，文件大小一般指的就是未命名数据流的大小。该属性没有最大最小限制，最小情况是该属性为常驻属性，可以不占用除MFT以外的空间。</p><h3 id="常驻80H类型属性结构"><a href="#常驻80H类型属性结构" class="headerlink" title="常驻80H类型属性结构"></a>常驻80H类型属性结构</h3><table><thead><tr><th align="center">字节偏移</th><th align="center">字段长度（字节）</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">～</td><td align="center">～</td><td align="center">标准属性头（已分析过）</td></tr><tr><td align="center">00H</td><td align="center"></td><td align="center">文件内容</td></tr></tbody></table><p>在标准属性头后面是该文件的内容。该内容以“00H”结束，这是因为文件属性的长度总是8的整数倍，当属性结束时并没有达到一个能被8整除的数字时就用“00H”来填充。</p><p><img src="https://s2.loli.net/2022/05/02/KC7Z8Lh5dOkp6sS.jpg" alt="80H（$DATA）属性分析-数据恢复迷"></p><h3 id="非常驻80H属性结构"><a href="#非常驻80H属性结构" class="headerlink" title="非常驻80H属性结构"></a>非常驻80H属性结构</h3><p>在NTFS文件系统中常用数据流有：</p><p>①［未命名］（［Unnamed］）</p><p>②{4c8cc155-6c1e-11d1-8e41-00c04fb9386d}</p><p>③^EDocumentSummaryInformation</p><p>④^ESebiesnrMkudrfcoIaamtykdDa</p><p>⑤^ESummaryInformation</p><p>⑥$MountMgrDatabase</p><p>⑦$Bad</p><p>⑧$SDS</p><p>⑨$J</p><p>⑩$Max</p><h4 id="未命名数据流"><a href="#未命名数据流" class="headerlink" title="未命名数据流"></a>未命名数据流</h4><p>80H属性的第一个未命名数据流也就是文件真正的数据，由Data Run来记录其属性体即文件数据的具体地址。</p><p><img src="https://s2.loli.net/2022/05/02/MDTVHQcpGfhqOU4.jpg" alt="80H（$DATA）属性分析-数据恢复迷"></p><center><b>Data Run含义的描述</b><table><thead><tr><th align="center"></th><th align="center">字节偏移</th><th align="center">字段长度（字节）</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">第一个Data Run的含义描述</td><td align="center">0x00</td><td align="center">1</td><td align="center">高4位为Data Run（数据流）的起始簇号在这个压缩字节中所占的字节数（N）；低4位表示Data Run所占用的簇数在该压缩字节中占用的字节数（L）</td></tr><tr><td align="center">0x01</td><td align="center">L</td><td align="center">Data Run（数据流）所占用的簇数</td><td align="center"></td></tr><tr><td align="center">L＋1</td><td align="center">N</td><td align="center">Data Run（数据流）的起始簇号</td><td align="center"></td></tr><tr><td align="center">第二个Data Run的含义描述</td><td align="center">L＋N＋1</td><td align="center">1</td><td align="center">高4位为Data Run的起始簇的相对簇数在这个压缩字节中所占的字节数（N1）；低4位表示Data Run所占的簇数在该压缩数据中占用的字节数（L1）</td></tr><tr><td align="center">L＋N＋2</td><td align="center">L1</td><td align="center">Data Run所占用的簇数</td><td align="center"></td></tr><tr><td align="center">L＋N＋L1＋2</td><td align="center">N1</td><td align="center">Data Run的起始簇的相对簇数，将此值加上第一个Data Run位置描述中的起始簇号，就是该Data Run的起始簇号（注意该值为带符号数）</td><td align="center"></td></tr><tr><td align="center">第三个及以后的Data Run含义同第二个Data Run</td><td align="center">……</td><td align="center">……</td><td align="center">……</td></tr></tbody></table><center><b>Run List的结构及含义</b>    </center><p><img src="https://s2.loli.net/2022/05/02/dkRmsH1btBQwG3x.jpg" alt="80H（$DATA）属性分析-数据恢复迷"></p><h3 id="文件的摘要信息"><a href="#文件的摘要信息" class="headerlink" title="文件的摘要信息"></a>文件的摘要信息</h3><p>这些摘要包括描述和来源两个部分，其中描述包括标题、主题、类别、关键字、备注等信息，而来源包括来源、作者、修订版本号码等信息。</p><p>而这些数据被存储在一组四条命名数据流中，它们分别是：</p><p>{4c8cc155-6c1e-11d1-8e41-00c04fb9386d}</p><p>^ EDocumentSummaryInformation</p><p>^ ESebiesnrMkudrfcoIaamtykdDa</p><p>^ ESummaryInformation</p><p>值得注意的是，后3个命名数据流的名字中的符号“^”是CTRL-E（05H），这样做的原因可能是不让普通用户访问该流。而{4c8cc155-6c1e-11d1-8e41-00c04fb9386d}流的内容总是为空</p><p><img src="https://s2.loli.net/2022/05/02/u2OHND9JvGgIrEX.jpg" alt="80H（$DATA）属性分析-数据恢复迷"></p><p>从{4c8cc155-6c1e-11d1-8e41-00c04fb9386d}数据流的属性头中可以看出，虽然其为非常驻属性，但是不论是系统分配给该属性的大小还是属性真实大小和最初的属性大小都是0，也就是说该数据流为空。</p><center><b>包含文件摘要的数据流</b>    </center><table><thead><tr><th align="center">数据流</th><th align="center">包含的文件摘要</th><th align="center">数据类型</th></tr></thead><tbody><tr><td align="center">^EDocumentSummaryInformation</td><td align="center">类别</td><td align="center">ASCII码</td></tr><tr><td align="center">^ESebiesnrMkudrfcoIaamtykdDa</td><td align="center">来源</td><td align="center">Unicode编码</td></tr><tr><td align="center">^ESummaryInformation</td><td align="center">标题<br>主题<br />作者<br>关键字<br>备注<br>修订版号码</td><td align="center">ASCII码</td></tr></tbody></table><h3 id="MountMgrDatabase-Data-Stream"><a href="#MountMgrDatabase-Data-Stream" class="headerlink" title="$MountMgrDatabase Data Stream"></a>$MountMgrDatabase Data Stream</h3><p>该数据流只存在有重解析点的卷上。</p><h3 id="Bad"><a href="#Bad" class="headerlink" title="$Bad"></a>$Bad</h3><p>坏簇数据流，该数据流只有在$BadClus元文件中才有，它是一个记录卷中簇的情况的数据流。任何好的簇、未用的簇及坏簇，都将在对应的位置做标记。NTFS不会像FAT系统那样提示“Abort，Retry，Fail?”，如果系统运行时新的坏簇被发现，系统将这个坏扇标记到坏簇文件（$BadClus）中。</p><h3 id="SDS"><a href="#SDS" class="headerlink" title="$SDS"></a>$SDS</h3><p>安全描述流（$SDS），只有在$Secure元文件中才有，它包含了卷中所有安全描述列表。</p><h3 id="J、-Max"><a href="#J、-Max" class="headerlink" title="$J、$Max"></a>$J、$Max</h3><p>这两个数据流只有$Extend$UsnJrnl元文件中才有。</p><h2 id="90H（-INDEX-ROOT）属性分析"><a href="#90H（-INDEX-ROOT）属性分析" class="headerlink" title="90H（$INDEX_ROOT）属性分析"></a>90H（$INDEX_ROOT）属性分析</h2><p><a href="https://www.dgxue.com/huifu/tag/90h/">90H</a>类型属性即$INDEX_ROOT，是索引根属性，该属性是实现NTFS的B＋树索引的根节点，它总是常驻属性。该属性没有最大最小长度限制。</p><p>结构：</p><p>标准属性头</p><p>索引根</p><p>索引头</p><p>索引项</p><p>索引项</p><p>…</p><h3 id="索引根"><a href="#索引根" class="headerlink" title="索引根"></a>索引根</h3><table><thead><tr><th>字节偏移</th><th>字段长度（字节）</th><th>描述</th></tr></thead><tbody><tr><td>～</td><td>～</td><td>标准属性头（已分析过）</td></tr><tr><td>0x00</td><td>4</td><td>属性类型</td></tr><tr><td>0x04</td><td>4</td><td>校对规则</td></tr><tr><td>0x08</td><td>4</td><td>每个索引缓冲区的分配大小（字节数）</td></tr><tr><td>0x0C</td><td>1</td><td>每个索引缓冲区的簇数</td></tr><tr><td>0x0D</td><td>3</td><td>无意义（填充到属性长度能被8整除）</td></tr></tbody></table><h3 id="索引头"><a href="#索引头" class="headerlink" title="索引头"></a>索引头</h3><table><thead><tr><th>字节偏移</th><th>字段长度（字节）</th><th>描述</th></tr></thead><tbody><tr><td>0x00</td><td>4</td><td>第一个索引项的偏移</td></tr><tr><td>0x04</td><td>4</td><td>索引项的总大小</td></tr><tr><td>0x08</td><td>4</td><td>索引项的分配大小</td></tr><tr><td>0x0C</td><td>1</td><td>标志：当该字节为00时，表示其为小索引（适合于索引根）；当该字节为01时，表示其为大索引（适合于索引分配）</td></tr><tr><td>0x0D</td><td>3</td><td>无意义（填充到属性长度能被8整除）</td></tr></tbody></table><h3 id="索引项"><a href="#索引项" class="headerlink" title="索引项"></a>索引项</h3><p>索引头后面有着不同长度的索引项的序列，由一个带有最后一个索引项标志的特殊索引项来结束。当一个目录比较小，可以全部存储在索引根属性中时，该目录就只需要这一个属性来描述。而如果目录太大不能全部存储在索引根中时，就会有两个附加的属性出现：一个是索引分配属性，描述B＋树目录的子节点；另一个是索引位图属性，描述索引块的索引分配属性使用的虚拟簇号。根目录$Root包含它自身的一个索引项。</p><p><img src="https://s2.loli.net/2022/05/02/qzKN73T89ZIPj25.jpg" alt="90H（$INDEX_ROOT）属性分析-数据恢复迷"></p><center><b>索引项描述</b><table><thead><tr><th>字节偏移</th><th>字段长度（字节）</th><th>描述</th></tr></thead><tbody><tr><td>0x00</td><td>8</td><td>该文件的MFT参考号</td></tr><tr><td>0x08</td><td>2</td><td>索引项的大小（相对索引项开始的偏移）</td></tr><tr><td>0x0A</td><td>2</td><td>文件名属性体大小</td></tr><tr><td>0x0C</td><td>2</td><td>索引标志：此处为1表示这个索引项包含子节点；为2表示这是最后一个项</td></tr><tr><td>0x0E</td><td>2</td><td>用0填充，无意义</td></tr><tr><td>0x10</td><td>8</td><td>父目录的MFT文件参考号</td></tr><tr><td>0x18</td><td>8</td><td>文件创建时间</td></tr><tr><td>0x20</td><td>8</td><td>文件最后修改时间</td></tr><tr><td>0x28</td><td>8</td><td>文件记录最后修改时间</td></tr><tr><td>0x30</td><td>8</td><td>文件最后访问时间</td></tr><tr><td>0x38</td><td>8</td><td>文件的分配大小</td></tr><tr><td>0x40</td><td>8</td><td>文件的实际大小</td></tr><tr><td>0x48</td><td>8</td><td>文件标志</td></tr><tr><td>0x50</td><td>1</td><td>文件名的长度</td></tr><tr><td>0x51</td><td>1</td><td>文件名的命名空间</td></tr><tr><td>0x52</td><td>2F</td><td>文件名</td></tr><tr><td>2F＋0x52</td><td>P</td><td>填充到能被8整除（无意义）</td></tr><tr><td>P＋2F＋0x52</td><td>8</td><td>子节点的索引所在的VCN（需要有子节点时才有）</td></tr></tbody></table><p><img src="https://s2.loli.net/2022/05/02/wTJGALBXhUm1Hgx.jpg" alt="90H（$INDEX_ROOT）属性分析-数据恢复迷"></p><h2 id="A0H（NDEX-ALLOCATION）属性分析"><a href="#A0H（NDEX-ALLOCATION）属性分析" class="headerlink" title="A0H（NDEX_ALLOCATION）属性分析"></a>A0H（NDEX_ALLOCATION）属性分析</h2><p><a href="https://www.dgxue.com/huifu/tag/a0h/">A0H</a>类型属性，即INDEX_ALLOCATION，它是索引分配属性，也是一个索引（如目录）的基本结构，存储着组成索引的B＋树目录所有子节点的定位信息。它总是非常驻属性，没有最大最小值限制。</p><center><b>A0H属性结构</b><table><thead><tr><th>字节偏移</th><th>字段长度（字节）</th><th>描述</th></tr></thead><tbody><tr><td>～</td><td>～</td><td>标准属性头（已分析过）</td></tr><tr><td>0x00</td><td>…</td><td>Data Run列表</td></tr></tbody></table><p><img src="https://s2.loli.net/2022/05/02/HKcMBVFLNfORZTJ.jpg" alt="A0H（NDEX_ALLOCATION）属性分析-数据恢复迷"></p><p>A0H属性的Run List所描述的数据流，也就是NTFS的B＋树结构的索引缓冲区。</p><h2 id="B0H（-BITMAP）属性分析"><a href="#B0H（-BITMAP）属性分析" class="headerlink" title="B0H（$BITMAP）属性分析"></a>B0H（$BITMAP）属性分析</h2><p><a href="https://www.dgxue.com/huifu/tag/b0h/">B0H</a>类型属性即$BITMAP，也就是位图属性，该属性是由一系列的位构成的虚拟簇（VCN）使用情况表，它没有最大最小限制。该属性目前用在两个地方：索引和$MFT中。在索引中，每一位代表索引分配中的一个VCN；在$MFT中，每一位代表一个文件记录的使用情况。</p><center><b>B0H属性描述表</b>    </center><p><img src="https://s2.loli.net/2022/05/02/iIz3ubxBfym5gRj.jpg" alt="B0H（$BITMAP）属性分析-数据恢复迷"></p><p><img src="https://s2.loli.net/2022/05/02/QoYkIx7EypfheZG.jpg" alt="B0H（$BITMAP）属性分析-数据恢复迷"></p><h2 id="C0H（-REPARSE-POINT）属性分析"><a href="#C0H（-REPARSE-POINT）属性分析" class="headerlink" title="C0H（$REPARSE_POINT）属性分析"></a>C0H（$REPARSE_POINT）属性分析</h2><p><a href="https://www.dgxue.com/huifu/tag/c0h/">C0H</a>类型属性，即$REPARSE_POINT，也就是重解析点属性。该属性没有最小字节数限制，但有最大字节数限制，其最大字节数为16 384字节。</p><p>文件或目录可以包含一个重解析点（用户定义数据的集合）。存储数据的程序和文件系统过滤器可以理解这种数据格式，所安装的这些程序和过滤器用于解释数据并处理文件。程序设置重解析点时，它会存储该数据和唯一标识所存储数据的重解析标记。当文件系统打开带有重解析点的文件时，它试图找到与由重解析标记标识的数据格式相联系的文件系统过滤器。如果找到了这样的文件系统过滤器，过滤器将在重分析数据的指导下处理文件。否则，打开文件的操作将会失败。</p><p>在Windwos 2003、Windows XP系统中可以用“fsutil reparsepoint ［query］ PathName”命令检索由指定的句柄识别的文件或目录的重分析点数据，也可以用“fsutil reparsepoint ［delete］ PathName”命令删除指定的文件或目录的重分析点。</p><p>重解析点中有一个称为“重解析数据”的数据块能够与文件或者目录相关联。重解析数据是用户定义的关于文件或者目录的数据。例如，文件的状态或者地址，创建这些数据的应用程序、文件系统过滤器驱动程序、I&#x2F;O管理器，都可以从重解析点读重解析数据。当NTFS在文件或者目录查找其间，遇到一个重解析点，它返回一个重解析状态代码，通知连接到卷上的文件系统过滤器驱动程序和I&#x2F;O管理器，检查重解析数据。每个重解析点类型有一个唯一的重解析标签。重解析标签允许负责转换重解析点的重解析数据的组件确认重解析点，而不用检查重解析数据。重解析标签的拥有者，是文件系统过滤器驱动程序或者I&#x2F;O管理器，在确认重解析数据时，可以选择以下的选项：</p><p>①重解析标签拥有者可以处理在文件I&#x2F;O操作中指定的跨越重解析点的路径名，并且用修改过的路径名重新发送I&#x2F;O操作。例如，连接就是利用这个方法重指向目录寻找。</p><p>②重解析标签拥有者可以从文件删除重解析点，以某些方法修改文件，然后重新发送文件I&#x2F;O操作。Windows 2003、Windows XP的分层存储管理（HSM）系统就是用这种方式使用重解析点。HSM将文件归档，将文件的内容转移到磁带，只剩下重解析点在它们的位置。当进程访问一个已经归档的文件，HSM过滤器驱动程序（*\System32\ Drivers\Rsfilter.sys）从文件删除重解析点，从归档的介质读文件的数据，重新发送访问请求。因此，对于访问归档文件的进程来说，获取离线数据是透明的。</p><center><b>C0H属性描述表</b>| 字节偏移 | 字段长度（字节） | 描述                               || -------- | ---------------- | ---------------------------------- || ～       | ～               | 标准属性头（已分析过）             || 0x00     | 4                | 重解析类型（和标志）               || 0x04     | 2                | 重解析数据长度                     || 0x06     | 2                | 填充到能被8整除，无意义            || 0x08     | V                | 重解析数据，其结构取决于重解析类型 |<center><b>重解析标志描述表</b><table><thead><tr><th>标志</th><th>描述</th><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>0x20000000</td><td>别名</td><td>0x68000007</td><td>SIS</td></tr><tr><td>0x40000000</td><td>高潜伏</td><td>0x68000008</td><td>DFS</td></tr><tr><td>0x80000000</td><td>微软</td><td>0x88000003</td><td>装载点</td></tr><tr><td>0x68000005</td><td>NSS</td><td>0xA8000004</td><td>HSM</td></tr><tr><td>0x68000006</td><td>NSS recover</td><td>0xE8000000</td><td>符号连接</td></tr></tbody></table><h2 id="D0H（-EA-INFORMATION）属性分析"><a href="#D0H（-EA-INFORMATION）属性分析" class="headerlink" title="D0H（$EA_INFORMATION）属性分析"></a>D0H（$EA_INFORMATION）属性分析</h2><p><a href="https://www.dgxue.com/huifu/tag/d0h/">D0H</a>类型属性，即$EA_INFORMATION，也就是扩充属性信息属性，它是为了在NTFS下实现用于HPFS的OS&#x2F;2子系统信息及Windows NT服务器的OS&#x2F;2客户端应用而设置的扩展属性。由于其数据流可以增长，所以该文件属性可能非常驻。该属性总是占8字节长度。</p><center><b>D0H类型属性描述表</b><table><thead><tr><th>字节偏移</th><th>字段长度（字节）</th><th>描述</th></tr></thead><tbody><tr><td>～</td><td>～</td><td>标准属性头（已分析过）</td></tr><tr><td>0x00</td><td>2</td><td>扩展属性填充尺寸</td></tr><tr><td>0x02</td><td>2</td><td>拥有NEED_EA设置的扩展属性数量</td></tr><tr><td>0x04</td><td>4</td><td>扩展属性非填充大小</td></tr></tbody></table><h2 id="E0H（-EA）属性分析"><a href="#E0H（-EA）属性分析" class="headerlink" title="E0H（$EA）属性分析"></a>E0H（$EA）属性分析</h2><p><a href="https://www.dgxue.com/huifu/tag/e0h/">E0H</a>类型属性，即$EA，也就是扩展属性，它用于在NTFS下实现HPFS。由于其数据流可能增长，所以该文件属性可能是非常驻的。该属性没有最小字节数限制，但最大只能达到65 536字节。扩展属性由“名称”和“值”成对组成</p><center><b>E0H属性描述表</b><table><thead><tr><th>字节偏移</th><th>字段长度（字节）</th><th>描述</th></tr></thead><tbody><tr><td>～</td><td>～</td><td>标准属性头（已分析过）</td></tr><tr><td>0x00</td><td>4</td><td>下一个扩展属性的偏移，也就是本偏移的长度</td></tr><tr><td>0x04</td><td>1</td><td>标志，当其值为80H时表示需要扩展属性</td></tr><tr><td>0x05</td><td>1</td><td>名称长度（N）</td></tr><tr><td>0x06</td><td>2</td><td>值长度（V）</td></tr><tr><td>0x08</td><td>N</td><td>名称</td></tr><tr><td>N＋0x08</td><td>V</td><td>值</td></tr></tbody></table><h2 id="100H（-LOGGED-UTILITY-STREAM）属性分析"><a href="#100H（-LOGGED-UTILITY-STREAM）属性分析" class="headerlink" title="100H（$LOGGED_UTILITY_STREAM）属性分析"></a>100H（$LOGGED_UTILITY_STREAM）属性分析</h2><p><a href="https://www.dgxue.com/huifu/tag/100h/">100H</a>类型属性，即$LOGGED_UTILITY_STREAM，即EFS加密属性。该属性主要用于存储实现EFS加密的有关加密信息，如合法用户列表、解码密钥等。正如$AttrDef所定义，该属性没有最小字节数限制，但最大只能到65 536字节。</p><center><b>100H类型属性描述表</b><table><thead><tr><th>字节偏移</th><th>字段长度（字节）</th><th>描述</th></tr></thead><tbody><tr><td>～</td><td>～</td><td>标准属性头（已分析过）</td></tr><tr><td>0x00</td><td></td><td>任意数据（EFS加密后的数据，或者是其Run List位置描述表）</td></tr></tbody></table><h2 id="元文件-MFTMirr分析"><a href="#元文件-MFTMirr分析" class="headerlink" title="元文件$MFTMirr分析"></a>元文件$MFTMirr分析</h2><p>$MFTMirr是系统以恢复为目的而创建的文件，它将$MFT文件中的几个记录做了备份。具体备份多少个文件记录取决于NTFS卷中每个簇的大小，至少需要做前4个文件记录的备份。当卷中簇远小于或等于4倍的文件记录大小（即小于或等于4KB）时，$MFTMirr就做前4个文件记录的备份。在Windows2003、Windows XP系统中默认的格式化簇的大小就是4KB，所以卷中的$MFTMirr大多只做了前4个文件记录的备份。如果簇的大小大于4KB时，那么$MFTMirr的数据流大小就等于一个簇，在一个簇中能备份多少个文件记录就会备份多少个，但一定是按文件记录的顺序进行备份的。</p><p>$MFTMirr的文件记录号为01H，一般由以下3种属性组成</p><p><img src="https://s2.loli.net/2022/05/02/62fmxkEw8vgnVsy.jpg" alt="元文件$MFTMirr分析-数据恢复迷"></p><h3 id="10H属性"><a href="#10H属性" class="headerlink" title="10H属性"></a>10H属性</h3><p>10H属性定义了$MFTMirr的创建时间、最后修改时间、该文件记录修改时间、文件最后访问时间及标志等信息。</p><h3 id="30H属性"><a href="#30H属性" class="headerlink" title="30H属性"></a>30H属性</h3><p>30H属性定义了$MFTMirr的父目录的文件参考号、系统分配给整个磁盘的MFTMirr的大小、实际使用的大小；再次定义了文件的标志为06H，表示其为隐藏、系统文件；定义了该文件名属性的文件名的长度为8个字、命名空间为3，即Win32 ＆ DOS；在属性的最后定义了该文件的文件名为Unicode字符串“$MFTMirr”</p><h3 id="80H属性"><a href="#80H属性" class="headerlink" title="80H属性"></a>80H属性</h3><p>80H属性定义了$MFTMirr数据流的起始VCN（本例中为0）、结束VCN（本例中为1）、起始LCN号（本例中为10H），以及所占的簇数（本例中为01H）等信息</p><blockquote><p>在80H属性之后跟着4个字节的“FF FF FF FF”，这是属性的结束标志，到此为止该文件记录中的属性就结束了。</p></blockquote><h2 id="元文件-LogFile分析"><a href="#元文件-LogFile分析" class="headerlink" title="元文件$LogFile分析"></a>元文件$LogFile分析</h2><p>日志文件的结构比较复杂，其日志区域由一系列4KB大小的日志记录组成，记录头固定标志是“RCRD”，其重启页的头部固定标志是“RSTR”，位于重启区域的开始部分。</p><p>当文件被写到磁盘上时，系统要做两件事，一是写文件本身的数据，二是更新和文件系统有关的一些数据（如文件创建时间）。如果此操作完成，则可以确认文件被写到存储单元上，并且文件系统处于正常状态。如果此操作未完成（如电源故障、系统瘫痪等），则文件系统处于非正常状态。NTFS系统将其恢复到正常状态的途径是在该特殊文件里记录日志，这个日志文件会记录某个操作的成功与失败。在系统故障后第一次进入磁盘时，系统读取日志文件并使其恢复到最后一次操作开始前的状态。当系统写日志文件时，操作必须是自动且即时的，可以在很短的时间内把卷恢复到正常状态，恢复时间与磁盘大小无关，只与失败任务的复杂程度有关。</p><h3 id="日志文件服务"><a href="#日志文件服务" class="headerlink" title="日志文件服务"></a>日志文件服务</h3><p>日志文件由格式化程序和日志文件服务（LogFile Service，LFS）共同创建。日志文件服务是一组NTFS驱动程序内的核心态程序。NTFS是通过LFS例程来访问日志文件的。</p><center><b>LFS结构示意图</b><p><img src="https://s2.loli.net/2022/05/02/ds1bka2nU6DNuVY.jpg" alt="元文件$LogFile分析-数据恢复迷"></p><p>LFS将日志文件分为两个区域：重启动区域（Restart Area）和无限记录区域（Infinite Logging Area）</p><center><b>日志文件结构</b>    </center><p><img src="https://s2.loli.net/2022/05/02/fUt1L6wRKPWXpmO.jpg" alt="元文件$LogFile分析-数据恢复迷"></p><p>NTFS使用重启动区域来存储系统故障后从哪里进行恢复的信息。在系统失败后的恢复过程中，NTFS将从这个位置开始读取信息。由于重启动区域的重要性，在紧随其后的磁盘空间上，LFS保存了它的一个副本。</p><p>在LFS重启动区域之后是记录区域，用于存放NTFS的日志记录，包含了改变文件系统数据和卷目录结构的I&#x2F;O操作的处理记录，由逻辑顺序号（Logical Sequence Numbers，LSN）来标识这些记录。LSN为64位，通过循环使用日志记录，LSN使日志文件看起来像是可以保存无限多的日志记录。</p><p>NTFS不会直接从日志文件中读&#x2F;写记录，而是通过LFS来读&#x2F;写记录。LFS提供了许多操作来处理日志文件，包括打开（Open）、写入（Write）、向前（Prev）、向后（Next）、更新（Update）等操作。在恢复过程中，NTFS通过向前读取日志记录，重做已在日志文件中记录的、系统失败时还没有及时刷新到磁盘上的所有事务；NTFS通过向后读取日志记录，撤销或是回退系统崩溃前没有完全记录在日志文件中的事务。当NTFS不再需要日志文件中较早的事务记录时，它就调用LFS来将日志文件的开始部分设置为一个具有更高LSN的记录，从而实现日志记录的“无限”使用。</p><p>NTFS为实现卷的可恢复性而执行的操作步骤：</p><p>①NTFS首先调用LFS在日志文件中记录所有改变卷结构的事务；</p><p>②NTFS执行在高速缓存中的更改卷结构的操作；</p><p>③高速缓存管理器调用LFS将日志文件刷新到磁盘；</p><p>④完成上一步之后，卷更改（事务本身）最后被刷新到磁盘上。</p><center><b>NTFS实现卷的可恢复性的操作步骤</b>    </center><p><img src="https://s2.loli.net/2022/05/02/XPsUjhA5rHZa62B.jpg" alt="元文件$LogFile分析-数据恢复迷"></p><h3 id="日志记录类型"><a href="#日志记录类型" class="headerlink" title="日志记录类型"></a>日志记录类型</h3><p>LFS允许用户在日志文件中写入任何类型的记录。<code>更新记录（Update Record）</code>和<code>检查点记录（Checkpoint Record）</code>是NTFS所支持的两种主要类型的日志记录，它们在系统的恢复过程中起了主要作用。</p><h3 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h3><p>NTFS为以下事务写入更新记录：</p><ul><li>创建文件</li><li>删除文件</li><li>扩展文件</li><li>截断文件</li><li>设置文件信息</li><li>重新命名文件</li><li>更改应用于文件的安全信息</li></ul><p>在更新记录中一般包含两种信息：</p><ol><li>重做信息：如果事务在高速缓存中的操作记录刷新到磁盘之前系统崩溃，如何重新执行这个对卷来说是已提交的事务子操作</li><li>撤销信息：当系统失败时，如何撤销这个对卷来说未提交的事务子操作</li></ol><center><b>日志文件中的更新记录</b>    </center><p><img src="https://s2.loli.net/2022/05/02/1DFrUdkiXonHSxB.jpg" alt="元文件$LogFile分析-数据恢复迷"></p><h3 id="检查点记录"><a href="#检查点记录" class="headerlink" title="检查点记录"></a>检查点记录</h3><p>NTFS在写入检查点记录以后，还在重启动区域存储记录的LSN。在发生系统失败后的恢复过程中，NTFS通过存储在检查点记录中的信息来定位日志文件中的恢复点</p><center><b>日志文件中的检查点记录</b>    </center><p><img src="https://s2.loli.net/2022/05/02/wG2Rj14OEhXTalI.jpg" alt="元文件$LogFile分析-数据恢复迷"></p><h3 id="可恢复性实现"><a href="#可恢复性实现" class="headerlink" title="可恢复性实现"></a>可恢复性实现</h3><ul><li><p>NTFS在内存中维护两张表：</p><p>①事务表。事务表跟踪已经启动但尚未提交的事务。在恢复过程中，必须从磁盘删除这些活动事务的子操作。</p><p>②脏页表。脏页表记录了在高速缓存中还未写入磁盘的包含改变NTFS卷结构操作的页面。在恢复过程中，这些改动必须刷新到磁盘上。</p><p>NTFS每隔5s向日志文件写入一个检查点记录，在此之前，NTFS调用LFS在日志文件中存储事务表和脏页表的一个当前副本。这样，NTFS写入的检查点记录就包含了已复制表的日志记录的LSN，当系统失败后开始恢复时，NTFS调用LFS来定位日志文件记录，这些日志记录包含了最近的检查点记录以及最近的事务表和脏页表的副本，然后，NTFS将这些表复制到内存。</p><p>在最近的检查点记录之后，日志文件通常包含更多的更新记录。这些更新记录显示了在最后的检查点记录写入后卷的更改。为此，NTFS必须更新事务表和脏页表，通过更新这些表和日志文件中的内容来更新卷本身。</p><p>要实现NTFS卷的恢复，NTFS要对日志文件进行三次扫描。</p><h3 id="分析扫描（Analysis-Pass）"><a href="#分析扫描（Analysis-Pass）" class="headerlink" title="分析扫描（Analysis Pass）"></a>分析扫描（Analysis Pass）</h3><p>NTFS从日志文件中最近的一个检查点操作的起点开始分析扫描。检查点操作起点之后的每一个更新记录都代表对事务表或脏页表的修改，如“事务提交”记录代表的事务必须从事务表中删除；“页面更新”记录则表示因为对一个文件系统数据结构做了修改，相应的脏页表也必须更新，如图4-440所示。</p><p><img src="https://s2.loli.net/2022/05/02/2crL173b9gOWTnz.jpg" alt="元文件$LogFile分析-数据恢复迷"></p><p>图4-440　分析扫描的过程</p><p>这两个表被复制到内存中以后，NTFS将搜索这两个表。事务表包含了未提交（不完整）事务的LSN，脏页表则包含了高速缓存中还未刷新到磁盘的记录的LSN。NTFS根据其中的信息来确定最早的更新记录（该记录记录了在磁盘上尚未进行的操作）的LSN，由此决定重做扫描的起点。当然，如果最近一个检查点记录更早，NTFS将从那里开始启动重做扫描，由此进入事务恢复的第二阶段。</p><h3 id="重做扫描（Redoing-Pass）"><a href="#重做扫描（Redoing-Pass）" class="headerlink" title="重做扫描（Redoing Pass）"></a>重做扫描（Redoing Pass）</h3><p>在重做扫描过程中，NTFS将从分析扫描得到的最早记录的LSN开始，在日志文件中向前扫描。NTFS将查找“页面更新”记录，这个记录包含了在系统失败前就已经写入的卷更新，但是这些卷的更改可能还未刷新到磁盘，NTFS将在高速缓存中重做这些更新。当NTFS到达日志文件的末端时，它已经利用必要的卷更改更新了高速缓存，高速缓存管理器的延迟写线程能够开始在后台向磁盘写入高速缓存的内容</p><p><img src="https://s2.loli.net/2022/05/02/yGqNxi6mnFp2Awh.jpg" alt="元文件$LogFile分析-数据恢复迷"></p><h3 id="撤销扫描（Undoing-Pass）"><a href="#撤销扫描（Undoing-Pass）" class="headerlink" title="撤销扫描（Undoing Pass）"></a>撤销扫描（Undoing Pass）</h3><p>在NTFS完成重做扫描后，它将开始撤销扫描。NTFS可以在这一扫描中回退系统失败时任何未提交的事务</p><p><img src="https://s2.loli.net/2022/05/02/ElScFhbzUDapj5X.jpg" alt="元文件$LogFile分析-数据恢复迷"></p><p>图4-442中有两个事务：事务1在断电时已经提交，事务2未提交。假设事务2创建一个文件，有3个子操作，它们之间通过指针连接。事务表为每个未提交的事务更新记录列出最后记录的LSN。</p><p>每个更新记录包含两种信息，一个是如何重做一个子操作，另一个是如何撤销子操作。NTFS在定位LSN1093后，执行撤销操作直到LSN1089，完成事务2的回退。当然，在日志文件中也要记录撤销操作，因为撤销时也可能发生系统崩溃。</p><p>恢复完成后，NTFS将高速缓存写入磁盘从而保证卷是最新的。最后，NTFS写入一个“空”到LFS重启动区，指明卷是一致的。这时，即使系统再次崩溃，也不必再恢复了。</p><p>由于NTFS使用的是“延迟提交”的算法，这意味着每次“事务提交”记录写入时，日志文件不能立即刷新到磁盘，而是被批处理写入的。同时，多个事务可能是平行操作的，它们的事务提交记录可能一部分被写入磁盘，而另一部分没有写入。这样就只能保证NTFS恢复到某一先前存在的一致状态，而不能保证NTFS恢复到刚巧系统崩溃时的状态。</p><p>NTFS还能够利用日志记录实现文件系统错误的恢复，因为NTFS日志记录了每个更改卷结构的事务，包括正常文件I&#x2F;O过程中发生的文件系统错误，所以日志文件可大大简化文件系统的错误处理代码。当然，一个程序收到的大多数I&#x2F;O错误不是文件系统错误，调用者必须适当地依次响应错误。</p><p><img src="https://s2.loli.net/2022/05/02/jRkTbhY6wqlpmSi.jpg" alt="元文件$LogFile分析-数据恢复迷"></p></li></ul><h3 id="日志文件的文件记录"><a href="#日志文件的文件记录" class="headerlink" title="日志文件的文件记录"></a>日志文件的文件记录</h3><p>$LogFile的文件记录号是02H，一般由3个属性构成。</p><p><img src="https://s2.loli.net/2022/05/02/djS6PK5ioLNVWBO.jpg" alt="元文件$LogFile分析-数据恢复迷"></p><h4 id="10H属性-1"><a href="#10H属性-1" class="headerlink" title="10H属性"></a>10H属性</h4><p>10H属性定义了$LogFile的创建时间、最后修改时间、该文件记录修改时间、文件最后访问时间及标志等信息</p><h4 id="30H属性-1"><a href="#30H属性-1" class="headerlink" title="30H属性"></a>30H属性</h4><p>30H属性定义了$LogFile的父目录的文件参考号为根目录；定义了系统分配给整个磁盘的日志文件的大小（本例中为04000000H字节）、实际使用的大小（本例中为04000000H字节）；并再次定义了文件的标志为06H，表示其为隐藏、系统文件，定义了文件名的长度为8个字，命名空间为3，也即Win32 ＆ DOS；在属性的最后定义了该文件的文件名为Unicode字符串“$LogFile”</p><h4 id="80H属性-1"><a href="#80H属性-1" class="headerlink" title="80H属性"></a>80H属性</h4><p>80H属性定义了日志文件的MFT的起始VCN（本例中为0）、结束VCN（本例中为3FFFH）、系统分配给该日志文件的大小（本例中为04000000H字节）、日志文件实际的大小（本例中为04000000H字节）、初始的属性大小（本例中为04000000H字节）、数据流的起始LCN（本例中为11H）、所占的簇数（本例中为4000H）等信息</p><p>在80H属性之后跟着4个字节的“FF FF FF FF”，这是属性的结束标志，到此为止该文件记录中的属性就结束了。</p><h3 id="日志文件的数据流"><a href="#日志文件的数据流" class="headerlink" title="日志文件的数据流"></a>日志文件的数据流</h3><p>系统用于记录日志操作的文件就是$Logfile文件的数据流部分。从其文件记录的80属性中可以看到$Logfile文件的数据流开始于11H簇，也就是十进制的17号簇，换算为扇区号为136扇区，该扇区就是其重启动记录</p><p><img src="https://s2.loli.net/2022/05/02/RjqTA1FZDU3BuhH.jpg" alt="元文件$LogFile分析-数据恢复迷"></p><p>重启动区域共有两份副本，每个大小为4KB，其结构见表4-78。</p><p>　重启动区域结构描述</p><table><thead><tr><th>字节偏移</th><th>字段长度（字节）</th><th>描述</th></tr></thead><tbody><tr><td>0x00</td><td>4</td><td>固定字符“RSTR”</td></tr><tr><td>0x1E</td><td>12</td><td>固定值</td></tr><tr><td>0x30</td><td>4</td><td>记录序列号a</td></tr><tr><td>0x58</td><td>4</td><td>记录序列号B</td></tr><tr><td>0x6C</td><td>1</td><td>卷干净标志</td></tr><tr><td>0x90</td><td>8</td><td>Unicode字符形式的“NTFS”</td></tr></tbody></table><p>无限记录区域的前4个字符一定是“RCRD”</p><p><img src="https://s2.loli.net/2022/05/02/ZnF1uWSjOVUxoC8.jpg" alt="元文件$LogFile分析-数据恢复迷"></p><h2 id="NTFS文件删除后的底层分析"><a href="#NTFS文件删除后的底层分析" class="headerlink" title="NTFS文件删除后的底层分析"></a>NTFS文件删除后的底层分析</h2><ul><li>数据区内容没有改变</li><li>文件记录的状态字节已经由01变为00（文件被删除)</li><li>30H属性中的文件名、80H属性中的文件大小、Runlist没有改变</li></ul><h3 id="删除后的恢复"><a href="#删除后的恢复" class="headerlink" title="删除后的恢复"></a>删除后的恢复</h3><p>将被删除的“huaban.jpg”文件的数据区的内容全部选中，并另存为一个新文件</p><h2 id="NTFS文件系统格式化的分析"><a href="#NTFS文件系统格式化的分析" class="headerlink" title="NTFS文件系统格式化的分析"></a>NTFS文件系统格式化的分析</h2><h3 id="格式化的底层分析"><a href="#格式化的底层分析" class="headerlink" title="格式化的底层分析"></a>格式化的底层分析</h3><p>• DBR里面的参数改变</p><p>•1号扇区里面的参数改变</p><p>•FAT1和FAT2被清空</p><p>•根目录也被清空，如果有卷标 那么会有一条卷标目录项</p><h2 id="NTFS文件系统DBR手工重建"><a href="#NTFS文件系统DBR手工重建" class="headerlink" title="NTFS文件系统DBR手工重建"></a>NTFS文件系统DBR手工重建</h2><p><img src="https://s2.loli.net/2022/05/03/R8pIiUdbyXrchD3.jpg" alt="NTFS文件系统DBR手工重建的实例-数据恢复迷"></p><p>这个分区“K”所在的硬盘没有任何物理故障，显然是文件系统遭到破坏，所以系统会提示分区未格式化。用WinHex打开分区“K”</p><p><img src="https://s2.loli.net/2022/05/03/ke1z8lGmPDTp2OV.jpg" alt="NTFS文件系统DBR手工重建的实例-数据恢复迷"></p><p>看来WinHex也无法打开分区“K”，可以断定<a href="https://www.dgxue.com/huifu/tag/dbr/">DBR</a>一定有错误，只能用WinHex打开分区“K”所在的硬盘，然后跳转到“K”盘的DBR扇区</p><p>首先考虑到NTFS分区的DBR有一个备份，在分区的最后一个扇区，如果能把这个DBR找到，直接复制过来就可以了。</p><p>先用WinHex跳转到硬盘最后一个分区，然后向上搜索“55 AA”，寻找备份DBR，若查找不到说明备份DBR也已经损坏</p><p><img src="https://s2.loli.net/2022/05/03/HUuniTcgvlPNXoe.jpg" alt="NTFS文件系统DBR手工重建的实例-数据恢复迷"></p><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><h4 id="第1步-复制同版本的DBR"><a href="#第1步-复制同版本的DBR" class="headerlink" title="第1步　复制同版本的DBR"></a>第1步　复制同版本的DBR</h4><p>先从其他NTFS分区中复制一个完好的DBR扇区，放到K盘的第一个扇区处，但不能把这个DBR当作K盘的DBR直接使用，因为虽然目前这个DBR在结构上没什么问题，但其中的参数与K盘的文件系统结构不匹配，所以无法用这个DBR访问K盘。</p><h4 id="第2步-计算并修改BPB参数"><a href="#第2步-计算并修改BPB参数" class="headerlink" title="第2步　计算并修改BPB参数"></a>第2步　计算并修改BPB参数</h4><p>NTFS文件系统的BPB中需要修改的参数有：</p><ul><li>每簇扇区数；</li><li>隐藏扇区数（也就是分区的相对开始扇区号）；</li><li>扇区总数（也就是分区大小）；</li><li>$MFT起始簇号；</li><li>$MFTMirr起始簇号；</li><li>文件记录的大小描述；</li><li>索引缓冲区的大小描述。</li></ul><p>这7个参数需要计算并修改，其他的就不用修改了。</p><p><img src="https://s2.loli.net/2022/05/03/pIuMaynsXEk8Pdw.jpg" alt="NTFS文件系统DBR手工重建的实例-数据恢复迷"></p><ol><li><h5 id="隐藏扇区数"><a href="#隐藏扇区数" class="headerlink" title="隐藏扇区数"></a>隐藏扇区数</h5>隐藏扇区数这个参数也就是分区的相对开始扇区号。如果硬盘的分区表没有被破坏，这个参数可以从分区表中查看。现在K盘的分区表并没有破坏，K盘是主扩展分区中的最后一个驱动器，找到它的EBR，用分区表模板查看这个分区表</li></ol><p><img src="https://www.dgxue.com/huifu/img/huifu/image01403.jpeg" alt="NTFS文件系统DBR手工重建的实例-数据恢复迷"></p><p>从分区表模板中可以看到“隐藏扇区数”为63。</p><h5 id="2-扇区总数"><a href="#2-扇区总数" class="headerlink" title="2. 扇区总数"></a>2. 扇区总数</h5><p>扇区总数也可以从分区表中看到，从上图的分区表模板可以看出扇区总数为132006042.因为是NTFS分区，所有DBR中记录的扇区总数比分区表少一个扇区，应该为132006041</p><h5 id="3-MFT起始蔟号"><a href="#3-MFT起始蔟号" class="headerlink" title="3. $MFT起始蔟号"></a>3. $MFT起始蔟号</h5><p>$MFT起始簇号可以通过搜索文件记录的方法获得，搜索文件记录的具体方法是搜索文件记录的头标志“46 49 4C 45”</p><p><img src="https://s2.loli.net/2022/05/03/peWPwgNM31smkvB.jpg" alt="NTFS文件系统DBR手工重建的实例-数据恢复迷"></p><p>$MFT的文件记录的80H属性中通过Run List描述$MFT文件的开始簇号。换算为十进制可以求出起始蔟号</p><h5 id="4-每簇扇区数"><a href="#4-每簇扇区数" class="headerlink" title="4. 每簇扇区数"></a>4. 每簇扇区数</h5><p>每簇扇区数的计算方法是找一个文件的文件记录，通过其非常驻的80H属性就可计算每簇扇区数。</p><p>找到“数据流分配大小和Runlist换算为十进制。用数据流分配的字节除以数据流占的簇数，结果就是每个簇的字节数，再除以512，就是每簇扇区数。</p><h5 id="5-文件记录大小的描述"><a href="#5-文件记录大小的描述" class="headerlink" title="5. 文件记录大小的描述"></a>5. 文件记录大小的描述</h5><p>文件记录的大小描述用来说明每个文件记录的簇数，该参数为带符号数。当每个文件记录的大小小于每簇扇区数，该值就是负数。在这种情况下，文件记录的大小用字节数表示。计算方法为：文件记录的字节数＝2-1×文件记录的大小描述。</p><h5 id="6-索引缓冲区的大小描述"><a href="#6-索引缓冲区的大小描述" class="headerlink" title="6. 索引缓冲区的大小描述"></a>6. 索引缓冲区的大小描述</h5><p>索引缓冲的大小描述用来说明每个索引缓冲区的簇数，该参数也是带符号数。当每个索引缓冲的大小小于每簇扇区数时，就为负值。</p><p>索引缓冲区的大小一般固定为8扇区，而该分区簇大小也是8扇区，所以每个索引缓冲区为1簇。</p><h5 id="7-MFTMirr起始蔟号"><a href="#7-MFTMirr起始蔟号" class="headerlink" title="7. $MFTMirr起始蔟号"></a>7. $MFTMirr起始蔟号</h5><p>刚才通过搜索找到了$MFT的文件记录，该记录的下一个记录也就是$MFTMirr的文件记录了，从$MFTMirr文件记录的80H属性中就能查看到$MFTMirr起始簇号。</p><h4 id="3-保存修改的BPB参数"><a href="#3-保存修改的BPB参数" class="headerlink" title="3.保存修改的BPB参数"></a>3.保存修改的BPB参数</h4><p>将计算好的7个BPB参数填入DBR中，如果有模板就用模板填，没有模板也可以直接在DBR中填写，但要注意，在模板中按照十进制填写，在DBR中直接填写则需要按照Little-Endian字节序填十六进制。填写好存盘，再双击就可以打开了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据恢复" scheme="https://github.com/HKingDragon/hkingdragon.github.io/categories/%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D/"/>
    
    
    <category term="文件系统" scheme="https://github.com/HKingDragon/hkingdragon.github.io/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
